<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>振动传感器主要性能指标</title>
    <url>/2021/06/14/%E6%8C%AF%E5%8A%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="灵敏度">灵敏度</h2>
<p>灵敏度是指沿传感器的测量方向，对应于每一单位简谐机械量的输入，其开路时电信号的输出，即输出比输入。</p>
<ul>
<li>输入的机械量：<span class="math inline">\(x=X\sin(\omega t
+\alpha)\)</span></li>
<li>输出的电信号：<span class="math inline">\(e=E\sin (\omega t+ \alpha
- \theta)\)</span>，<span class="math inline">\(\theta\)</span>
为相移，即输出的电信号<span
class="math inline">\(e\)</span>对被测机械量<span
class="math inline">\(x\)</span>的相位滞后</li>
<li>灵敏度：<span class="math inline">\(s=E/X\)</span> （电信号单位 /
机械量单位）</li>
</ul>
<p>通常，<span class="math inline">\(X\)</span>
是位移、速度、加速度、力、应变等，<span class="math inline">\(E\)</span>
是电压、电荷等。</p>
<h2 id="分辨率">分辨率</h2>
<p>分辨率是指传感器可感受到的被测量的最小变化的能力。</p>
<p>也就是说，如果输入量从某一非零值缓慢地变化，但变化值未超过某一数值
<span class="math inline">\(\Delta X\)</span> 时，传感器的输出变化量
<span class="math inline">\(\Delta E =0\)</span>
，即传感器对此输入量的变化是分辨不出来的。只有当输入量的变化超过分辨率时，其输出才会发生变化。</p>
<p><span class="math inline">\(\Delta X\)</span>
越小，灵敏度越高，分辨率也越高。灵敏度越高，传感器的信噪比将相应下降，这将降低测量结果的精度，故应综合考虑。</p>
<h2 id="线性度和线性范围">线性度和线性范围</h2>
<p>通常情况下，传感器的实际静态特性输出是条曲线而非直线。在实际工作中，为使仪表具有均匀刻度的读数，常用一条拟合直线近似地代表实际的特性曲线。</p>
<p><strong>线性度</strong>（非线性误差）<span
class="math inline">\(\gamma\)</span>
就是这个近似程度的一个性能指标，定义为在全量程范围内实际特性曲线与拟合直线之间的最大偏差值与满量程输出值之比。</p>
<p><span class="math display">\[
\gamma=\frac{ \Delta E }{  E_{max} -  E_{min} } \times 100 \\%
\]</span></p>
<p><strong>线性范围</strong>是指传感器测量量与实际被测量之间保持近似线性关系的范围。</p>
<p><img src="/image/zhendongceshi/xianxingdu.png" width = "60%" height = "60%"  align=center /></p>
<h2 id="频率范围">频率范围</h2>
<p><strong>频率范围</strong>是指传感器的灵敏度随频率的变化量不超出某一给定的误差限的频率范围（频率上限和下限）。传感器的频率范围取决于：
1. 机械接收部分的频率特性。 1. 机电变换部分和所用二次仪表的频率特性。 1.
传感器的安装条件也影响频率上限。</p>
<p>备注： * 在制定测量方案时，首先要看传感器的频率范围是否满足测量的要求
* 压电式加速度传感器具有较宽的频率范围，而且频率上限也比较高 *
电阻式、压阻式和伺服式等三种加速度传感器都具有零频率响应，其中压阻式也具有较高的上限频率</p>
<h2 id="固有频率与安装谐振频率">固有频率与安装谐振频率</h2>
<p>对于惯性式接收传感器，其机械接收部分是由质量块、阻尼器、弹簧构成的单自由度振动系统，其质量、阻尼、刚度分别为
<span class="math inline">\(m, c,
k\)</span>。该振系统无阻尼自由振动的频率 $ _n = $
被称为传感器的<strong>固有频率</strong>。</p>
<p>传感器产生共振时的最低频率称为<strong>安装谐振频率</strong>，若安装刚度是有限的（实际上也很难达到无穷大），则其对传感器的接收特性将有较大影响。</p>
<h2 id="工作范围">工作范围</h2>
<p>频率范围和线性范围一起决定了传感器的<strong>工作范围</strong>。工作范围可以从诺谟图（Nomogram）中得到</p>
<p><img src="/image/zhendongceshi/nuomotu.jpg" width = "50%" height = "50%"  align=center /></p>
<h2 id="横向灵敏度与方向特性">横向灵敏度与方向特性</h2>
<p>横向灵敏度主要是由于最大灵敏度轴与传感器的几何轴线不重合而引起的。这是由于传感器加工、安装上的间歇误差等条件造成的。最大灵敏度的轴线与几何轴线间的夹角为
<span
class="math inline">\(\theta\)</span>，<strong>最大的横向灵敏度</strong>表示为：</p>
<p><span class="math display">\[
s_t=\tan \theta
\]</span></p>
<p>备注： * 加速度传感器的外壳上的红点被用来表示横向灵敏度的方向。 *
一般令红点和传感器中心的连线，与振幅最大的非被测振动方向垂直，以减少测量误差。</p>
<h2 id="动态范围">动态范围</h2>
<p><strong>动态范围</strong>是指某一输入机械量的幅值范围（用分贝表示），该范围内传感器的灵敏度随输入机械量幅值的变化量不超出某一给定的误差限。</p>
<p><span class="math display">\[
D=20 \lg \frac{X_{max}}{X_{min}}
\]</span></p>
<p>动态范围越大，说明传感器对幅值变化的适应能力越强。比如 <span
class="math inline">\(D=80dB\)</span>，则幅值上限与下限之比达10000倍。传感器的量程即是指其幅值上限与下限值的代数差。</p>
<h2 id="其他">其他</h2>
<p>传感器的其它性能参数还包括其质量、重复性、稳定性、输入输出阻抗、阻尼、迟滞、零飘、过载能力、以及它的工作环境条件等。</p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>实验模态分析的基本原理与主要过程</title>
    <url>/2021/06/14/%E5%AE%9E%E9%AA%8C%E6%A8%A1%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="模态分析">模态分析</h3>
<p><strong>模态分析</strong>是研究结构动力特性一种方法，一般应用在工程振动领域。</p>
<p>其中，<strong>模态</strong>是指机械结构的固有振动特性，每一个模态都有特定的固有频率、阻尼比和模态振型。分析这些模态参数的过程称为模态分析。</p>
<p>按计算方法，模态分析可分为： *
计算模态分析：由有限元计算的方法取得待识别参数 *
试验模态分析：通过试验将采集的系统输入与输出信号经过参数识别获得待识别参数</p>
<p><strong>通常，模态分析都是指试验模态分析。</strong></p>
<h3 id="实验模态分析">实验模态分析</h3>
<p><strong>实验模态分析</strong>主要是通过模态试验，测量系统的振动响应信号或同时测量系统的激励信号和响应信号，从测量信号中，识别描述系统动力特征的有关参数。</p>
<p>试验模态分析结果可以验证和修改结构数学模型、综合试验分析模型、校核动态计算分析结果的有效性、分析结构产品性能、检查结构中的薄弱部位、鉴定结构总体设计的合理性。</p>
<h3 id="待识别参数">待识别参数</h3>
<ul>
<li>物理参数：质量矩阵、刚度矩阵、阻尼矩阵等</li>
<li>模态参数：固有频率、衰减系数、模态矢量、模态刚度、模态阻尼</li>
</ul>
<h3 id="模态分析系统的组成">模态分析系统的组成</h3>
<ul>
<li>激振系统：使得系统产生稳态、瞬态或随机振动
<ul>
<li>稳态正弦激振法</li>
<li>瞬态激振法
<ul>
<li>快速正弦扫描激振法</li>
<li>脉冲锤击激振法</li>
</ul></li>
<li>随机激振法
<ul>
<li>纯随机激振法</li>
<li>伪随机激振法</li>
<li>周期随机激振法</li>
</ul></li>
</ul></li>
<li>测量系统：用传感器测量实验对象的各个主要部位上的位移、速度或加速度信号，然后将这些信号与激振信号一起记录并保存</li>
<li>分析系统：将保存的激励信号和响应信号经过数模转换，采样并输入数字式分析仪或计算机中，用硬件或软件系统识别振动系统的模态参数</li>
</ul>
<h2 id="实验模态分析的基本原理">实验模态分析的基本原理</h2>
<h3 id="基本原理">基本原理</h3>
<p>本部分以多自由度动力学系统为例，阐明了实验模态分析的<strong>基本原理</strong>：
对于多自由度动力学常微分方程 <span
class="math inline">\(\rightarrow\)</span> 对其拉氏变换 <span
class="math inline">\(\rightarrow\)</span> 得到传递函数 <span
class="math inline">\(\rightarrow\)</span> 通过振型的正交性 <span
class="math inline">\(\rightarrow\)</span>
发现传递函数中含有模态参数的信息 <span
class="math inline">\(\rightarrow\)</span>
因此可以通过实验可以得到传递函数 <span
class="math inline">\(\rightarrow\)</span>
再从传递函数中识别得到振动系统有关参数 <span
class="math inline">\(\rightarrow\)</span>
最后进一步计算得到待求模态参数</p>
<h3 id="传递函数与模态参数的关系">传递函数与模态参数的关系</h3>
<p>对于多自由度动力学系统，其动力学方程为：</p>
<p><span class="math display">\[
\textbf{M}\bar{\ddot{x} }+\textbf{C}\bar{ \dot{x}
}+\textbf{K}\bar{x}=\bar{f}
\]</span></p>
<p>对其进行拉氏变换：</p>
<p><span class="math display">\[
\textbf{M}\left[ s^2 \bar{X}(s) - s\bar{x}(0) - \bar{\dot{x} }(0)
\right] + \textbf{C} \left[  s\bar{X}(s) - \bar{x}(0) \right] +
\textbf{K} \bar{X}(s) = \bar{F}(s)
\]</span></p>
<p>初始条件全为0时：</p>
<p><span class="math display">\[
\left[ s^2 \textbf{M} + s \textbf{C} + \textbf{K} \right] \bar{X}(s) =
\bar{F}(s)
\]</span></p>
<p>根据传递函数的定义，系统的传递函数为：</p>
<p><span class="math display">\[
\textbf{H}(s)=\frac{\bar{X}(s)}{\bar{F}(s)} = \frac{ 1}{ s^2 \textbf{M}
+ s \textbf{C} + \textbf{K} }
\]</span></p>
<blockquote>
<p>机械系统中<strong>传递函数的定义</strong>：零初始条件下线性系统响应（即输出）量的拉普拉斯变换与激励（即输入）量的拉普拉斯变换之比。</p>
</blockquote>
<p>利用振型的正交性，当模态振型矩阵为$ []
$时，模态质量矩阵、模态阻尼矩阵、模态刚度矩阵为：</p>
<p><span class="math display">\[
\textbf{M}_r = [\varphi]^\mathrm{T}\textbf{M}[\varphi] =
\mathrm{diag}(m_1 \, \cdots \, m_r \, \cdots \, m_N)
\]</span></p>
<p><span class="math display">\[
\textbf{C}_r = [\varphi]^\mathrm{T}\textbf{C}[\varphi]
=  \mathrm{diag}(c_1 \, \cdots \, c_r \, \cdots \, c_N)
\]</span></p>
<p><span class="math display">\[
\textbf{K}_r = [\varphi]^\mathrm{T}\textbf{K}[\varphi] =
\mathrm{diag}(k_1 \, \cdots \, k_r \, \cdots \, k_N)
\]</span></p>
<p>将上式代入传递函数，可得到：</p>
<p><span class="math display">\[
\textbf{H}(s)= [\varphi] \left[ s^2 \textbf{M}_r + s \textbf{C}_r +
\textbf{K}_r \right]^\mathrm{-1}[\varphi]^\mathrm{T}
\]</span></p>
<p>将传递函数矩阵展开可以发现，它的每一行或每一列都包含有所有的模态信息：模态质量矩阵、模态阻尼矩阵、模态刚度矩阵中所有元素以及所有模态矢量。</p>
<h3
id="实验传递矩阵和模态参数的关系">实验、传递矩阵和模态参数的关系</h3>
<p>若固定在一点测量振动响应信号，而不断改变激励信号的作用点，这样就测量出了传递函数的一行；若固定在一点进行激励，而在不同点进行振动响应信号测量，这样就测量出了传递函数的一列。</p>
<p>从上一节的分析中可知，传递函数矩阵的每一行或每一列都包含有所有的模态信息。<strong>因此，只要通过实验测得传递函数矩阵的一行或一列再加以分析计算，就可以得到全部的模态信息。</strong></p>
<p>从传递函数中求出模态参数的方法，被称为<strong>参数识别方法</strong>。一般通用的参数识别方法有两种：图解法和曲线拟合法。</p>
<ul>
<li><p>图解法是利用频响函数曲线直接进行模态识别的方法。其优点是简便、直观，缺点是精度差、不能排除外界干扰。</p></li>
<li><p>曲线拟合法是用一条连续曲线去拟合一组离散的实验数据，然后利用拟合曲线识别有关参数的方法。该方法常利用图解法所识别的参数作为初始值进行迭代优化计算，直到满足精度为止，从而可以从传递函数中识别得到振动系统有关参数，最后进一步计算得到待求模态参数。</p></li>
</ul>
<h2 id="实验模态分析的主要过程">实验模态分析的主要过程</h2>
<p>根据实验模态分析的基本原理，现将实验模态分析的主要过程总结如下： 1.
确定实验模型，将实验结构支撑起来（边界条件的确定） 1.
进行模态试验，利用上述激振方法进行激励实验结构（一般用锤击法），记录原点和各测点的激励、响应时间历程曲线
1.
对各测点的时间历程数据进行数字处理，利用传递函数与模态参数的关系和时/频域转换技术求出各测点的传递函数，并组成传递函数矩阵
1. 利用参数识别方法进行参数识别，求得模态参数 1. 进行模态动画展示</p>
<p><img src="/image/zhendongceshi/motaifenxiguocheng.png" width = "45%" height = "45%"  align=center /></p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶变换（FFT）基本原理</title>
    <url>/2021/06/15/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>快速傅里叶变换（FFT）是离散傅里叶变换（DFT）的加速算法，而DFT则是将连续的傅里叶变换离散化（在时域和频域离散），连续傅里叶变换可由傅里叶展开式推导得出。</p>
<p>正向逻辑为： 傅里叶展开式 <span
class="math inline">\(\rightarrow\)</span> 推导得到 <span
class="math inline">\(\rightarrow\)</span> 连续傅里叶变换对 <span
class="math inline">\(\rightarrow\)</span> 离散后得到 <span
class="math inline">\(\rightarrow\)</span> 离散傅里叶变换 <span
class="math inline">\(\rightarrow\)</span> 开发加速算法 <span
class="math inline">\(\rightarrow\)</span> 快速傅里叶变换 ## 傅里叶变换
### 三角函数形式 对于一个周期为 <span class="math inline">\(T\)</span>
的信号 <span class="math inline">\(x(t)\)</span>，其基频为 <span
class="math inline">\(f_1=1/T\)</span>。对 <span
class="math inline">\(x(t)\)</span> 进行傅里叶展开：</p>
<p><span class="math display">\[
x(t) = \frac{a_0}{2} +\sum^{\infty}_ {n=1} \left[ a_n \cos\left(2\pi n
f_1 t \right) + b_n \sin\left(2\pi n f_1 t \right) \right]
\]</span></p>
<p>上式中的 <span class="math inline">\(a_n\)</span> 和 <span
class="math inline">\(b_n\)</span> 是傅里叶系数：</p>
<p><span class="math display">\[
a_n = \frac{2}{T} \int^T_ 0 x(t) \cos \left( 2\pi n f_1 t \right) dt
\]</span></p>
<p><span class="math display">\[
b_n = \frac{2}{T} \int^T_ 0 x(t) \sin \left( 2\pi n f_1 t \right) dt
\]</span></p>
<h3 id="指数形式">指数形式</h3>
<p>根据欧拉公式，可以将傅里叶变换式写为指数形式，指数形式看起来更为简洁，利于推导。
根据欧拉公式，有以下变换：</p>
<p><span class="math display">\[
\cos \left( 2\pi n f_1 t \right) = \frac{1}{2} \left[ e^{j2\pi n f_1 t}
+  e^{-j2\pi n f_1 t} \right]
\]</span></p>
<p><span class="math display">\[
\sin \left( 2\pi n f_1 t \right) = \frac{1}{2j} \left[ e^{j2\pi n f_1 t}
-  e^{-j2\pi n f_1 t} \right]
\]</span></p>
<blockquote>
<p>欧拉公式：<span class="math inline">\(e^{ix} = \cos x + i \sin
x\)</span></p>
</blockquote>
<p>带入傅里叶展开式，可得：</p>
<p><span class="math display">\[
x(t) = \frac{a_0}{2} +\sum^{\infty}_ {n=1} \left[ \frac{a_n}{2} \left[
e^{ j 2\pi n f_1 t } + e^{ -j 2\pi n f_1 t } \right] + \frac{b_n}{2j}
\left[ e^{ j 2\pi n f_1 t } - e^{ -j 2\pi n f_1 t } \right]  \right]
\]</span></p>
<p>合并同类项可得：</p>
<p><span class="math display">\[
x(t) = \frac{a_0}{2} +\sum^{\infty}_ {n=1} \left[ \frac{a_n - j
b_n}{2}  e^{ j 2\pi n f_1 t }  + \frac{a_n + b_n}{2}  e^{ -j 2\pi n f_1
t } \right]
\]</span></p>
<p>观察指数项前的系数，令</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{a_n - j b_n}{2}
\]</span></p>
<p>则有：</p>
<p><span class="math display">\[
X(-2\pi n f_1) = \frac{a_n + j b_n}{2}
\]</span></p>
<p>发现指数项前的系数具有奇偶性，利用奇偶性并改变求和符号的下限，将展开式改写为：</p>
<p><span class="math display">\[
x(t) = \sum^{\infty}_ {n=-\infty}  X(2\pi n f_1)   e^{ j 2\pi n f_1 t
}   
\]</span></p>
<p>注意，此时求和符号的下限由一变为负无穷，<span class="math inline">\(1
\rightarrow -\infty\)</span>。式中的 $X(2n f_1) $ 展开后为：</p>
<p><span class="math display">\[
\begin{gathered}
X(2\pi n f_1) =\frac{1}{2} \left[ \frac{2}{T} \int^T_ 0 x(t) \cos \left(
2\pi n f_1 t \right) dt - \frac{2j}{T} \int^T_ 0 x(t) \sin \left( 2\pi n
f_1 t \right) dt \right] \\\\
= \frac{1}{T} \int^T_ 0 x(t) \left[ \cos \left( 2\pi n f_1 t \right) - j
\sin \left( 2\pi n f_1 t \right) \right] dt
\end{gathered}
\]</span></p>
<p>再利用欧拉公式，可得：</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{1}{T} \int^T_ 0 x(t)   e^{ -j 2\pi n f_1 t} dt
\]</span></p>
<p><strong>总结上述推导过程，得到指数形式的傅里叶变换对：</strong></p>
<p><span class="math display">\[
x(t) = \sum^{\infty}_ {n=-\infty}  X(2\pi n f_1)   e^{ j 2\pi n f_1 t
}   
\]</span></p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{1}{T} \int^T_ 0 x(t)   e^{ -j 2\pi n f_1 t} dt
\]</span></p>
<p>以上两个公式中，第二式才是<strong>傅里叶变换</strong>，第一式是傅里叶变换反演公式。</p>
<p>当信号没有周期，即周期无穷大时 <span
class="math inline">\(T\rightarrow \infty\)</span>，有<span
class="math inline">\(f_1\rightarrow
0\)</span>，此时第一式的求和符号可以改写为积分号，<span
class="math inline">\(f_1\)</span>
可以被当作是一个连续变化的量，傅里叶变换对就被改写为了连续形式。</p>
<h3 id="傅里叶变换的实际意义">傅里叶变换的实际意义</h3>
<p>傅里叶变换对第一式：表示被采集信号 <span
class="math inline">\(x(t)\)</span> 可以由具有不同频率（<span
class="math inline">\(2\pi n f_1\)</span>）和幅值（<span
class="math inline">\(X(2\pi n f_1)\)</span>）的周期信号叠加得到。</p>
<p>傅里叶变换对第二式：为傅里叶变换，表示不同频率分量前的系数，可以理解为，该频率分量在被采集信号中的占比。</p>
<p><strong>傅里叶变换的目的</strong>：得到被采集信号包含的频率成分和每个频率成分在原信号中的占比，用图形表示则为频谱图。</p>
<h2 id="离散傅里叶变换">离散傅里叶变换</h2>
<p>离散傅里叶变换对应的是在时域、频域都有限长，且都是离散的一类变换。</p>
<p>现有一个时域模拟信号 <span
class="math inline">\(x(t)\)</span>，对其进行采样，采样长度为 <span
class="math inline">\(T\)</span>, 采样点有 <span
class="math inline">\(N\)</span> 个，采样时间间隔为 <span
class="math inline">\(\Delta t\)</span>。</p>
<p>则采样长度与采样点的关系为：</p>
<p><span class="math display">\[
T=N\Delta t
\]</span></p>
<p>采样频率为：</p>
<p><span class="math display">\[
f_s = \frac{1}{\Delta t}
\]</span></p>
<p>频谱的基频是<span class="math inline">\(f_1\)</span>，即：</p>
<p><span class="math display">\[
f_1=\frac{1}{T}
\]</span></p>
<p>根据傅里叶变换公式，由傅里叶变换求得的频谱谱线都是基频的整数倍，即频谱谱线的间隔：</p>
<p><span class="math display">\[
\Delta f=f_1=\frac{1}{T} = \frac{1}{N\Delta t}
\]</span></p>
<p>记采样得到的离散的时域数字信号为<span class="math inline">\(x(k\Delta
t)\)</span>，把傅里叶变换式中的连续变量替换为离散变量</p>
<p><span class="math display">\[
t=k\Delta t,\quad 2\pi nf_1=2\pi n \Delta f
\]</span></p>
<p>再将<span class="math inline">\(T=N\Delta
t\)</span>带入傅里叶变换对，对时间积分变为有限时间段内求和，即，<span
class="math inline">\(\int \rightarrow \sum\)</span>，<span
class="math inline">\(dt\rightarrow\Delta t\)</span>，得到：</p>
<p><span class="math display">\[
x(k\Delta t) = x(k)= \sum^{N-1}_ {n=0}  X(2\pi n \Delta f)   e^{ j 2\pi
n k / N }   
\]</span></p>
<p><span class="math display">\[
X(2\pi n \Delta f) =X(n)= \frac{1}{N} \sum^{N-1}_ {k=0}  x(k\Delta t)
e^{ -j 2\pi n k /N}
\]</span></p>
<p>习惯上将标定因子 <span class="math inline">\(N\)</span>
移至反变换式中去，并且用 <span class="math inline">\(n\)</span> 表示第
<span class="math inline">\(n\)</span> 个采样点，用 <span
class="math inline">\(k\)</span> 表示第 <span
class="math inline">\(k\)</span> 条谱线（频率分量），即将上式中 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(k\)</span> 的位置互换。总结上述结论有：</p>
<p><span class="math display">\[
x(n) = \frac{1}{N} \sum^{N-1}_ {n=0}  X(k)   e^{ j 2\pi n k / N }   
\]</span></p>
<p><span class="math display">\[
X(k) = \sum^{N-1}_ {k=0}  x(n) e^{ -j 2\pi n k /N}
\]</span></p>
<p>上式就是<strong>离散傅里叶变换式</strong>。式中：</p>
<p><span class="math display">\[
k= 0,1,2\dots,N-1; \quad n= 0,1,2\dots,N-1
\]</span></p>
<p>根据离散傅里叶变换式可以求出第 <span class="math inline">\(n\)</span>
条谱线对应的傅里叶系数的值，即该频率分量在整个信号中的占比。</p>
<p>我们注意到离散傅里叶变换式中求和符号的上下限改变了，不再是正负无穷。再改为正负无穷可以吗？改了之后两个公式含义还一样吗？答案是一样的，要用采样定理回答该问题。虽然标注是无穷，但是采样频率一定要大于2倍的被采样信号最高频率：</p>
<p><span class="math display">\[
f_s=\frac{1}{\Delta t}&gt;2f_m
\]</span></p>
<p>当采样频率已经确定为 <span class="math inline">\(1/ \Delta t\)</span>
时，满足采样定理的 <span class="math inline">\(x(t)\)</span>
的最高频率分量是：</p>
<p><span class="math display">\[
f_m&lt;\frac{1}{2}f_s=\frac{1}{2\Delta t} = \frac{1}{2} N \Delta f
\]</span></p>
<p>即满足采样定理的最后一根谱线所在的频率为<span
class="math inline">\(1/(2N\Delta f)\)</span>，换而言之 <span
class="math inline">\(k\)</span> 最大为 <span
class="math inline">\(N/2\)</span>。</p>
<h2 id="快速傅里叶变换">快速傅里叶变换</h2>
<h3 id="fft提出的背景">FFT提出的背景</h3>
<p>使用离散傅里叶变换时，计算一点的 <span
class="math inline">\(X(n)\)</span> 需要 <span
class="math inline">\(N\)</span> 次复数乘法和 <span
class="math inline">\(N-1\)</span> 次复数加法运算；计算全部的频谱需要
<span class="math inline">\(N^2\)</span> 次复数乘法和 <span
class="math inline">\(N(N-1)\)</span>
次复数加法。而实现1次复数乘法需要4次实数乘法和2次实数加法，实现1次复数加法，需要2次实数加法。<span
class="math inline">\(N=1024\)</span>时，需要 <span
class="math inline">\(1048576\)</span> 次复数乘法运算。</p>
<p>有没有什么方法可以缩短计算时间呢？</p>
<p>1965年J. W. Cooley 和 J. W. Tukey
提出了一种快速求解DFT的算法，将乘法运算量由 <span
class="math inline">\(N^2\)</span> 降低至 <span
class="math inline">\(\frac{N}{2} \log_ 2 N\)</span> 次。以 <span
class="math inline">\(N=1024\)</span> 为例，他们提出的算法，只需要 <span
class="math inline">\(5120\)</span> 次复数乘法运算。</p>
<p><strong>值得注意的是FFT不是特指某一种算法，而是指一类算法</strong>，自1965年后也有许多优秀学者提出了新的FFT算法。</p>
<h3 id="fft基本原理">FFT基本原理</h3>
<p>对于 <span class="math inline">\(N\)</span> 点序列 <span
class="math inline">\(x(n)\)</span>，其 DFT变换对为：</p>
<p><span class="math display">\[
x(n) = \frac{1}{N} \sum^{N-1}_ {n=0}  X(k) W^{-nk}_ N
\]</span></p>
<p><span class="math display">\[
X(k) = \sum^{N-1}_ {k=0}  x(n) W^{nk}_ N
\]</span></p>
<p>其中，<span class="math inline">\(W_ N = e^{-j2\pi /N}\)</span>
。</p>
<p>DFT还可以写成矩阵形式，定义 <span
class="math inline">\(\mathbf{W}_N\)</span> 为：</p>
<p><span class="math display">\[
\mathbf{W}_N = \left[ W^{nk} \right]= \begin{bmatrix} W^0 &amp; W^0
&amp; W^0 &amp; \cdots &amp; W^0 \\\\  W^0 &amp; W^1 &amp; W^2 &amp;
\cdots &amp; W^{N-1} \\\\ W^0 &amp; W^2 &amp; W^4 &amp; \cdots &amp;
W^{2(N-1)} \\\\  \vdots &amp; \vdots &amp; \vdots &amp; \vdots
&amp;  \vdots  \\\\  W^0 &amp; W^{(N-1)} &amp; W^{2(N-1)} &amp; \cdots
&amp; W^{(N-1)(N-1)} \end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\bar{X}_N = \begin{bmatrix} X(0) &amp;  X(1) &amp;  \cdots &amp;  X(N-1)
\end{bmatrix}^\mathrm{T}
\]</span></p>
<p><span class="math display">\[
\bar{x}_N = \begin{bmatrix} x(0) &amp;  x(1) &amp;  \cdots &amp;  x(N-1)
\end{bmatrix}^\mathrm{T}
\]</span></p>
<p>则DFT的矩阵表达式为：</p>
<p><span class="math display">\[
\bar{X}_N = \mathbf{W}_N \bar{x}_N
\]</span></p>
<p>观察矩阵形式的DFT表达式，可以发现DFT中包含大量重复运算，矩阵 <span
class="math inline">\(\mathbf{W}_N\)</span> 虽然有 <span
class="math inline">\(N^2\)</span> 个元素，但是其中只有 <span
class="math inline">\(N\)</span>
个独立值，并且一部分元素的值极为简单。<span
class="math inline">\(W\)</span> 因子的取值有如下特点：</p>
<ul>
<li><span class="math inline">\(W^0=1\)</span>, <span
class="math inline">\(W^{N/2}=-1\)</span></li>
<li><span class="math inline">\(W^{N+r}=W^r\)</span>, <span
class="math inline">\(W^{N/2+r}=-W^r\)</span></li>
</ul>
<p>对于4点的DFT，需要 <span class="math inline">\(4^2=16\)</span>
次复数乘法，但是利用 <span class="math inline">\(W\)</span>
因子的周期性和对称性可以大大简化计算，相关的DFT矩阵格式为：</p>
<p><span class="math display">\[
\begin{bmatrix} X(0) \\\\  X(1) \\\\  X(2) \\\\  X(3) \end{bmatrix} =
\begin{bmatrix} 1 &amp;  1 &amp;  1 &amp;  1 \\\\  1 &amp;  W^1
&amp;  -1 &amp;  -W^1 \\\\  1 &amp;  -1 &amp;  1 &amp;  -1 \\\\ 1
&amp;  -W^1 &amp;  -1 &amp;  W^1  \end{bmatrix}\begin{bmatrix} x(0)
\\\\  x(1) \\\\  x(2) \\\\  x(3) \end{bmatrix}
\]</span></p>
<p>将矩阵的第二列和第三列交换，可得：</p>
<p><span class="math display">\[
\begin{bmatrix} X(0) \\\\  X(1) \\\\  X(2) \\\\  X(3) \end{bmatrix} =
\begin{bmatrix} 1 &amp;  1 &amp;  1 &amp;  1 \\\\  1 &amp;  -1
&amp;  W^1 &amp;  -W^1 \\\\  1 &amp;  1 &amp;  -1 &amp;  -1 \\\\ 1
&amp;  -1 &amp;  -W^1 &amp;  W^1  \end{bmatrix}\begin{bmatrix} x(0)
\\\\  x(2) \\\\  x(1) \\\\  x(3) \end{bmatrix}
\]</span></p>
<p>由此可得：</p>
<p><span class="math display">\[
\begin{gathered}
X(0) = [x(0) + x(2)] + [x(1) + x(3)]  \\\\
X(1) = [x(0) - x(2)] + [x(1) - x(3)] W^1  \\\\
X(2) = [x(0) + x(2)] - [x(1) + x(3)] W^1 \\\\
X(3) = [x(0) - x(2)] - [x(1) - x(3)]  
\end{gathered}
\]</span></p>
<p>利用上式计算DFT只需要 <span class="math inline">\(1\)</span>
次复数乘法运算。处理长序列时，只需要将长序列分成类似于上式或比上式更简短的序列后，进行简单的运算，再按一定方式组合起来即可。</p>
<p>因此，<strong>FFT的基本原理是</strong>：先将原始的序列分解为一系列的短序列，充分利用
<span class="math inline">\(W\)</span>
因子的周期性和对称性，进而求出这些短序列相应的DFT并进行适当组合，达到删除重复计算，减少乘法运算和简化结构的目的。</p>
<p>对于大部分FFT算法，有一些通用的概念和规律： *
<strong>级</strong>：将原信号每次折半，分为更小的单元，每折半一次，多出一级
*
<strong>蝶形单元</strong>：在FFT计算过程中，计算并不是顺序的，画出信号流图会发现，信号流图中包含着大量8字型（类似于蝴蝶）的计算单元
* <strong>组</strong>：每一级的蝶形单元，按照其特性可以分为若干组 *
<strong><span
class="math inline">\(W\)</span>因子的分布</strong>：每一级的 <span
class="math inline">\(W\)</span> 因子具有一定的分布规律 *
<strong>码位倒置</strong>：使用FFT时，输出序列 <span
class="math inline">\(\bar{X}_N\)</span>
依照正序排列，但是输入序列的次序不再是自然序列，其排布次序和二进制码翻转、二进制与十进制转换有关</p>
<p>本文不再详细叙述具体的FFT算法。</p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Levenberg–Marquardt Algorithm</title>
    <url>/2021/06/24/levenberg%E2%80%93Marquardt_Algorithm/</url>
    <content><![CDATA[<h2 id="问题背景">问题背景</h2>
<p>在使用Matlab或Python解决某些实际问题时，我们不免要求解非线性方程组，或解决一些优化问题。这时你就有可能遇到
<strong>Levenberg–Marquardt 算法</strong>。</p>
<h2 id="levenbergmarquardt-算法">Levenberg–Marquardt 算法</h2>
<p>Levenberg–Marquardt
算法是一种最小二乘（模型拟合）算法。它可以解决以下问题：</p>
<p><span class="math display">\[
\min_{x}f(x)= \min_{x} \\| F(x) \\|^2_2 = \min_{x} \sum_i F_i^2(x)
\]</span></p>
<p>即求一个 <span class="math inline">\(x\)</span> 使 <span
class="math inline">\(f(x)\)</span> 最小。</p>
<p>1944年<a href="https://doi.org/10.1090/qam/10666">Kenneth
Levenberg</a>首次提出该算法，1963年<a
href="https://doi.org/10.1137/0111030">Donald
Marquardt</a>也发现了该算法，后来这种算法被称作Levenberg–Marquardt。</p>
<p>关于该算法的详细原理和实现可以参考 Flannery 等人的著作 <a
href="http://www.nrbook.com/a/bookcpdf.php">Numerical recipes in
C</a>。</p>
<h2 id="levenbergmarquardt-算法与非线性方程组求根">Levenberg–Marquardt
算法与非线性方程组求根</h2>
<p>求解非线性方程组即求解一组 <span
class="math inline">\(\bar{x}\)</span> 令其满足 <span
class="math inline">\(\bar{F}(x)=0\)</span>。显然非线性方程组的根可以令上式成立。</p>
<p>因此，给定初始值，通过Levenberg–Marquardt 算法求得的 <span
class="math inline">\(\bar{x}\)</span> 就是非线性方程组 <span
class="math inline">\(\bar{x}\)</span> 的一组近似根（初始值附近）。</p>
<p>非线性方程组的根显然不止一组，而通过该方法只能得到距离初始值较近的根，要想得到全部的根，需要配合其他算法。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>Levenberg, K. (1944). A method for the solution of certain
non-linear problems in least squares. <em>Quarterly of applied
mathematics</em>, 2(2), 164-168.</li>
<li>Mardquardt, D. W. (1963). An algorithm for least square estimation
of parameters. <em>J. Soc. Ind. Appl. Math</em>, 11, 431-441.</li>
<li>Flannery, B. P., Press, W. H., Teukolsky, S. A., &amp; Vetterling,
W. (1992). Numerical recipes in C. <em>Press Syndicate of the University
of Cambridge, New York</em>, 24(78), 36.</li>
</ul>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在论文中完美插入矢量图</title>
    <url>/2021/06/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AE%BA%E6%96%87%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E7%9F%A2%E9%87%8F%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="问题背景">问题背景</h2>
<p>论文写作时，我们往往需要插入矢量图，以保证图形被阅览时不会因缩放而出现难看的锯齿（失真）。</p>
<p>需要矢量图的常用场景如下： * 纯矢量图 * 简单的折线、柱形、条形图等 *
抽象的模型图、概念图、流程图、程序框图等 *
混合类图形，混合了以上两种图形 * 矢量图与位图的混合 *
色彩复杂的模型图（位图）旁配上文字、简单的折线图、流程图等 *
在流程图中嵌入各种结果，如Science、Nature中常见的占用一页的超大混合类图形
* 其他</p>
<h2 id="各种类型图片的区别">各种类型图片的区别</h2>
<h3 id="矢量图">矢量图</h3>
<p>简单来说矢量图就像用几何图形来描述一幅图，在矢量图放大时，我们所记录的几何图形的各种角度、形状等并没有改变，所以无论是放大还是缩小，都不会影响矢量图的清晰度。</p>
<p><strong>文件类型：</strong> Adobe
Illustrator的<code>.AI</code>、<code>.EPS</code>和<code>.SVG</code>、AutoCAD的<code>.dwg</code>和<code>.dxf</code>、Corel
DRAW的<code>.cdr</code>等。<code>.pdf</code>也常被用来保存矢量图。</p>
<p><strong>制图：</strong> 使用Adobe
Illustrator(AI)、CorelDRAW、FlashMX制图</p>
<h3 id="位图">位图</h3>
<p>位图又被称作点阵图或栅格图像，它的特点就是，整幅图由许多的‘点’组成，这些‘点’我们称为“像素”。在位图模式下，计算机会将图片的每个像素点进行保存。当位图放大到一定程度时，我们会发现图片是由一个一个的小方块组成，这些小方块就是像素点。</p>
<p><strong>文件类型：</strong>
<code>.jpg</code>、<code>.png</code>、<code>.bmp</code>、<code>.pcx</code>、<code>.gif</code>、<code>.tif</code>、<code>.psd</code>等。</p>
<p><strong>制图：</strong>
使用Photoshop、Painter和Windows系统自带的画图工具制图。</p>
<h2 id="如何在论文中使用矢量图">如何在论文中使用矢量图</h2>
<p><strong>这里主要讨论使用LaTex写作时，如何插入矢量图。</strong></p>
<p><strong>第一步</strong>：使用任何软件得到矢量图形。如果使用Matlab、Python得到折线、柱形图等，直接输出为<code>.pdf</code>或<code>.eps</code>格式。如果使用Visio、PPT等软件绘制流程图、模型图，导出为<code>.pdf</code>。（貌似微软的办公软件不支持<code>.eps</code>）</p>
<p>（如果是直接插入已得到的矢量图，请转至第三步）</p>
<p><strong>第二步</strong>：使用Adobe
Illustrator将多个矢量图组合在一起后用快捷键<code>Shift+o</code>裁剪画布，删去边框。将文件保存为<code>.eps</code>或<code>.pdf</code>。如果只是删除<code>.pdf</code>中的白边，使用Adobe
Acrobat 的编辑功能就能轻松做到。</p>
<p><strong>第三步</strong>：在LaTex中插入组合好的矢量图。</p>
<p><strong>提示</strong>：在第一步制作矢量图时，最好调整好字号，图宽以适合出现在论文中或PPT中，并且使用Matlab时一定要保存一份<code>.fig</code>文件，便于以后查找修改。</p>
<h2 id="office套件中插入矢量图">Office套件中插入矢量图</h2>
<p>Office办公软件下插入矢量图，使用<code>.emf</code>即可。Office系列间的互通是较为方便的，如Visio、PPT、Word间相互插入文件。</p>
<p>使用Word和Latex一段时间以后，还是非常推荐大家使用LaTex的（强迫症福音）。毕竟插入的行内、行间公式怎是一个“服服帖帖”就能概括的。更别说切换模板时，只需要改动导言区就ok啦，简直不要太方便。LaTex缺点也有，表格制作很麻烦QAQ…，整体学习成本略高。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>https://www.zhihu.com/question/378251607/answer/1160351444</li>
</ul>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT和伯德图 (Bode plot) 的区别与联系</title>
    <url>/2021/08/06/FFT-and-Bode-plot/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p><strong>主要区别</strong>： *
作用对象。FFT作用于<strong>时间序列信号</strong>；Bode图作用于系统<strong>传递函数</strong>
<span class="math inline">\(H(s)\)</span> *
目的。FFT的目的是得到一段信号的频谱；Bode图的目的是得到传递函数的幅频特性和相频特性
*
原理。FFT基于<strong>傅里叶变换</strong>；Bode图基于<strong>拉普拉斯变换</strong>
*
适用性。FFT分析的时间序列可以来自于线性系统或非线性系统；Bode图只能分析<strong>线性非时变系统</strong>的传递函数</p>
<p><strong>主要联系</strong>： * 两者都得到频域下的结果 *
在数学形式上，得到传递函数时使用的拉普拉斯变换退化后得到傅里叶变换</p>
<h2 id="傅里叶变换">傅里叶变换</h2>
<p><strong>傅里叶变换的目的</strong>：得到被采集信号包含的频率成分和每个频率成分在原信号中的占比，用图形表示则为频谱图。</p>
<p>傅里叶变换简单通俗理解就是把看似杂乱无章的信号考虑成由一定振幅、相位、频率的基本正弦（余弦）信号组合而成，傅里叶变换的目的就是找出这些基本正弦（余弦）信号中振幅较大（能量较高）信号对应的频率，从而找出杂乱无章的信号中的主要振动频率特点。如减速机故障时，通过傅里叶变换做频谱分析，根据各级齿轮转速、齿数与杂音频谱中振幅大的对比，可以快速判断哪级齿轮损伤。</p>
<p>傅里叶正变换可以写为： <span class="math display">\[
X(j\omega) = \int^{+\infty}_ {-\infty} x(t)   e^{ -j \omega t} dt
\]</span></p>
<p>但是，我们发现傅里叶变换中的基函数是 <span
class="math inline">\(e^{j\omega
t}\)</span>，能用它拟合的函数具有共同特征，那就是，各个频率下的三角函数分量不随时间衰减。这个假设具有明显的局限性，要么是理想没有阻尼的系统，要么是研究有阻尼的系统对特定频率的瞬时响应。</p>
<p>因此需要对傅里叶变换的基函数进行拓展，由此引出拉普拉斯变换：</p>
<p><span class="math display">\[
e^{\sigma t}e^{j\omega t}=e^{(\sigma+j\omega) t}=e^{st}
\]</span></p>
<p>其中，<span class="math inline">\(s=\sigma+j\omega\)</span>
为拉普拉斯变换中的变量，表示复实数（<span
class="math inline">\(j\)</span>为虚数单位）。</p>
<p>PS：有关傅里叶变换的详细内容可以参照另一篇博客：<a
href="https://alkaidwood.github.io/2021/06/15/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">快速傅里叶变换（FFT）基本原理</a>。</p>
<h2 id="拉普拉斯变换">拉普拉斯变换</h2>
<p>拉普拉斯变换可以写为： <span class="math display">\[
X(\sigma+j\omega)=\int^{+\infty}_ {-\infty} x(t)   e^{(\sigma+j\omega)
t} dt=\int^{+\infty}_ {-\infty} x(t)   e^{s t} dt=X(s)
\]</span></p>
<p><span class="math display">\[
X(s)=\int^{+\infty}_ {-\infty} x(t)   e^{s t} dt
\]</span></p>
<p>拓展傅里叶变换得到拉普拉斯变换。它是为简化计算而建立的实变量函数和复变量函数间的一种函数变换。对一个实变量函数作拉普拉斯变换，并在复数域中作各种运算，再将运算结果作拉普拉斯反变换来求得实数域中的相应结果，往往比直接在实数域中求出同样的结果在计算上容易得多。拉普拉斯变换的这种运算步骤对于求解线性微分方程尤为有效，它可把微分方程化为容易求解的代数方程来处理，从而使计算简化。在经典控制理论中，对控制系统的分析和综合，都是建立在拉普拉斯变换的基础上的。</p>
<p><strong>引入拉普拉斯变换的一个主要优点，是可采用传递函数 <span
class="math inline">\(H(s)\)</span>
代替微分方程来描述系统的特性</strong>。这就为采用直观和简便的图解方法来确定控制系统的整个特性（见信号流程图、动态结构图）、分析控制系统的运动过程（见奈奎斯特稳定判据、根轨迹法），以及综合控制系统的校正装置（见控制系统校正方法）提供了可能性。</p>
<h2 id="bode图">Bode图</h2>
<p>刚才提到，通过拉普拉斯变换可以得到系统的传递函数；而传递函数可以直观的反应线性系统输入与输出之间的关系。当我们对传递函数可视化时往往就会用到<strong>Bode图</strong>。</p>
<p>伯德图(bode)利用对数表示系统传递函数的幅频、相频特性,它分为两个图，一个是对数幅频图、一个是相频图，横坐标均为
<span class="math inline">\(\omega\)</span> ，纵坐标一个为<span
class="math inline">\(L(\omega)=20\lg A(\omega
)\)</span>表示对数幅值，一个为<span class="math inline">\(\varphi
(\omega)\)</span> 表示相位角。</p>
<blockquote>
<p><strong>例</strong>：Bode图 假设系统的传递函数为： <span
class="math display">\[
H(s)=\frac{A}{s+a}
\]</span> <span
class="math inline">\(s=\sigma+j\omega\)</span>，则传递函数可以写为：
<span class="math display">\[
H(\sigma+j\omega)=\frac{A}{(\sigma+j\omega)+a}
\]</span> 此时传递函数的图像是三维的，有两个自变量<span
class="math inline">\(\sigma 和
\omega\)</span>，但是Bode图只关系其中的<span
class="math inline">\(\omega\)</span>，将另一个变量视为0，<span
class="math inline">\(\sigma=0\)</span>： <span class="math display">\[
H(\omega)=\frac{A}{(j\omega)+a}
\]</span> 上式的对数幅值和相角分别为： <span class="math display">\[
L(\omega)=20\lg \big\vert H(\omega) \big \vert = 20\lg \bigg(
\frac{A}{\sqrt{\omega^2+a^2}} \bigg )
\]</span> <span class="math display">\[
\varphi (\omega) = - \arctan \frac{\omega}{a}
\]</span> 利用以上两式即可画出Bode图，横坐标均为<span
class="math inline">\(\omega\)</span></p>
</blockquote>
<hr />
<p>本文参考了以下博主分享的文章： * <a
href="https://blog.csdn.net/Davidietop/article/details/105369349">信号处理趣学D8——关于拉氏变换和频谱图的那些事儿</a>
* <a
href="https://www.zhihu.com/question/22085329">傅里叶变换、拉普拉斯变换、Z
变换的联系是什么？为什么要进行这些变换？</a> * <a
href="https://blog.csdn.net/Davidietop/article/details/102768194">MATLAB频域分析,奈氏图、伯德图、对数幅相图绘制</a>
* <a href="https://en.wikipedia.org/wiki/Bode_plot">Bode plot -
Wikipeida</a> * <a
href="https://zhuanlan.zhihu.com/p/148778408">傅里叶变换和拉普拉斯变换的物理解释及区别</a>
* <a href="https://zhuanlan.zhihu.com/p/228219488">Bode
Plots（伯德图）</a></p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文中的高频英语词汇</title>
    <url>/2021/08/15/%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E9%AB%98%E9%A2%91%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/</url>
    <content><![CDATA[<h2 id="动词">动词</h2>
<p>引起学术界的广泛关注 generate a good deal of academic attention</p>
<h2 id="名词">名词</h2>
<p>发生 occur 处理 process &gt;&gt; deal with &gt; handle 大量关注 a lot
of attention</p>
<h2 id="形容词">形容词</h2>
<p>各种各样的 various</p>
<h2 id="副词">副词</h2>
<p>特别地 in particular &gt; especially</p>
<h2 id="连接词或短语">连接词或短语</h2>
<p>同时 at the same time &gt;&gt; meanwhile 此外 furthermore = moreover
在...的基础上 on the basis of 随后 in the fllowing</p>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>加权残值伽辽金法</title>
    <url>/2021/08/26/%E5%8A%A0%E6%9D%83%E6%AE%8B%E5%80%BCGalerkin%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p><strong>加权残值伽辽金法</strong> (Galerkin method of weighted
residuals) 也被称作加权余量伽辽金法、伽辽金法 (Galerkin
method)，常被看作是<strong>加权残值（余量）法</strong>的一种。该方法是俄罗斯数学家鲍里斯·格里戈里耶维奇·伽辽金
(Boris Galerkin)
发明的一种数值分析方法。应用这种方法可以将求解微分方程问题简化成为线性方程组的求解问题。</p>
<p><strong>伽辽金法原理概述：</strong>
采用微分方程对应的<strong>弱形式</strong>，通过选取有限多项试函数（又称基函数或形函数），将它们叠加；再要求结果在求解域内及边界上的加权积分（权函数为试函数本身）满足原方程，便可以将求解微分方程近似解的问题转化为求解一组线性代数方程，且自然边界条件能够自动满足。</p>
<p>必须强调指出的是，伽辽金法所得到的只是在原求解域内的一个近似解（仅仅是加权平均满足原方程，并非在每个点上都满足）。</p>
<p>为了阐明伽辽金法的原理及特点，本文先介绍相关概念——微分方程的<strong>等效积分形式</strong>和<strong>弱形式</strong>，再介绍加权残值伽辽金法的基本步骤和特点。</p>
<h2 id="等效积分弱形式">等效积分弱形式</h2>
<p>数学中,
<strong>微分方程的弱解</strong>或广义解是指对该方程中的微分可能不存在,
但是在某种精确定义的意义下满足该方程的解。 对于不同种类的微分方程,
弱解的定义性质也可能不同。</p>
<p>设函数 <span class="math inline">\(\mathbf{u}\)</span> 在域 <span
class="math inline">\(\Omega\)</span> 中满足如下微分方程组：</p>
<p><span class="math display">\[
\mathbf{A}(\mathbf{u}) = 0
\]</span></p>
<p>域 <span class="math inline">\(\Omega\)</span>
可能是体积域或面积域。同时未知函数 <span
class="math inline">\(\mathbf{u}\)</span> 还要在边界 <span
class="math inline">\(\Gamma\)</span> 满足边界条件：</p>
<p><span class="math display">\[
\mathbf{B}(\mathbf{u}) = 0
\]</span></p>
<p>由于微分方程组在域 <span class="math inline">\(\Omega\)</span>
中的每一点都必须为0，因此有：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{v} ^\mathrm{T} \mathbf{A}(\mathbf{u}) \mathrm{d}
\Omega \equiv \int _\Omega \left( v _1 A _1 (\mathbf{u})+v _2 A _2
(\mathbf{u})+\cdots \right)\mathrm{d} \Omega \equiv 0
\]</span></p>
<p>上式的数字下标代表对应向量的分量，<span
class="math inline">\(\mathbf{v}\)</span>
是一组与微分方程个数相等的任意函数。</p>
<p>假如边界条件在边界上每一点也同时得到满足，则对任意一组函数 <span
class="math inline">\(\bar{\mathbf{v}}\)</span>，下式成立：</p>
<p><span class="math display">\[
\int _\Gamma \bar{\mathbf{v}} ^\mathrm{T} \mathbf{B}(\mathbf{u})
\mathrm{d} \Gamma \equiv \int _\Gamma \left( \bar{v} _1 B _1
(\mathbf{u})+ \bar{v} _2 B _2 (\mathbf{u})+\cdots \right)\mathrm{d}
\Gamma \equiv 0
\]</span></p>
<p>因此有：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{v} ^\mathrm{T} \mathbf{A}(\mathbf{u}) \mathrm{d}
\Omega + \int _\Gamma \bar{\mathbf{v}} ^\mathrm{T}
\mathbf{B}(\mathbf{u}) \mathrm{d} \Gamma  \equiv 0
\]</span></p>
<p>上式是与微分方程组 <span
class="math inline">\(\mathbf{A}(\mathbf{u})=0\)</span>
完全等效的<strong>等效积分形式</strong>。</p>
<p>在很多情况下可以对上式进行分部积分得到另一种形式：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{C} ^\mathrm{T} (\mathbf{v}) \mathbf{D}(\mathbf{u})
\mathrm{d} \Omega + \int _\Gamma \mathbf{E} ^\mathrm{T}
(\bar{\mathbf{v}}) \mathbf{F}(\mathbf{u}) \mathrm{d} \Gamma  \equiv 0
\]</span></p>
<p>其中 <span class="math inline">\(\mathbf{C}, \mathbf{D}, \mathbf{E},
\mathbf{F}\)</span> 是微分算子，与分部积分之前的 <span
class="math inline">\(\mathbf{A}\)</span>
相比，他们所包含的导数的阶数较低，这样对函数 <span
class="math inline">\(\mathbf{u}\)</span>
只需求较低阶的连续性就可以了。上式中降低 <span
class="math inline">\(\mathbf{u}\)</span> 的连续性是以提高 <span
class="math inline">\(\mathbf{v}\)</span> 及 <span
class="math inline">\(\mathbf{v^{&#39;}}\)</span>
的连续性为代价的。然而，适当提高 <span
class="math inline">\(\mathbf{v}\)</span>
的连续性并不困难，因为它们是可以选择的已知函数。</p>
<p>这种通过适当提高对任意函数 <span
class="math inline">\(\mathbf{v}\)</span> 及 <span
class="math inline">\(\mathbf{v^{&#39;}}\)</span>
的连续性要求，以降低对微分方程场函数 <span
class="math inline">\(\mathbf{u}\)</span>
的连续性要求所建立的等效积分形式称为微分方程 <span
class="math inline">\(\mathbf{A}\)</span>
的<strong>等效积分弱形式</strong>。等效积分弱形式的解称为<strong>微分方程的弱解</strong>。</p>
<h2 id="加权残值伽辽金法">加权残值伽辽金法</h2>
<h3 id="概述-1">概述</h3>
<p>采用使余量的加权积分为零来求得微分方程近似解的方法称为<strong>加权残值法</strong>，也称加权余量法。加权残值法是一种<strong>基于等效积分形式的近似方法</strong>。根据所选取权函数的不同，加权残值法可分为：配点法、子域法、最小二乘法、力矩法和<strong>加权残值伽辽金法</strong>。</p>
<p>在应用数学中，加权残值法被用来求解微分方程的近似解，<strong>具体步骤</strong>如下：
1. 假设近似解的形式是有限个<strong>试探函数</strong>（或基函数、形函数）
<span class="math inline">\(\mathbf{N} _i\)</span>
的叠加，叠加时的系数为 <span class="math inline">\(\mathbf{a}
_i\)</span>。 1.
由于近似解不能精确满足原微分方程和边界条件，近似解带入原微分方程和边界条件后将产生<strong>残差/余量</strong>（等式左端不为零的项）。
1.
将得到的关于残差的方程写作<strong>等效积分形式</strong>，并用规定的<strong>权函数</strong>
<span class="math inline">\(\mathbf{W} _j\)</span> 代替任意函数 <span
class="math inline">\(\bar{v}\)</span>。 1.
令得到的由残差和权函数表示的微分方程等于零，可求得待定系数 <span
class="math inline">\(\mathbf{a}
_i\)</span>，最终得到了原微分方程的近似解。</p>
<p><strong>Notation：用近似解的试探函数 <span
class="math inline">\(\mathbf{N} _j\)</span> 作为权函数 <span
class="math inline">\(\mathbf{W} _j\)</span> 时 (<span
class="math inline">\(\mathbf{W} _j = \mathbf{N}
_j\)</span>)，上述步骤被称为加权残值伽辽金法。</strong></p>
<h3 id="具体推导">具体推导</h3>
<p>在求解域 <span class="math inline">\(\Omega\)</span> 中，若场函数
<span class="math inline">\(\mathbf{u}\)</span> 是精确解，则在域 <span
class="math inline">\(\Omega\)</span> 中的任何一点都满足微分方程 <span
class="math inline">\(\mathbf{A}(\mathbf{u})=0\)</span>，同时在边界
<span class="math inline">\(\Gamma\)</span> 上满足边界条件 <span
class="math inline">\(\mathbf{B}(\mathbf{u})=0\)</span>，此时等效积分式或其弱形式必然也得到严格满足。但是对于复杂的实际问题，这样的精确解往往很难找到，因此需要设法找到具有一定精度的近似解。</p>
<p>假设未知场函数 <span class="math inline">\(\mathbf{u}\)</span>
可以用近似函数表示。近似函数是带有待定参数的已知函数一般形式是：</p>
<p><span class="math display">\[
\mathbf{u}  \approx \mathbf{u}^* = \sum ^n _{i=1} \mathbf{N} _i
\mathbf{a} _i = \mathbf{N} \mathbf{a}
\]</span></p>
<p>其中 <span class="math inline">\(\mathbf{a} _i\)</span>
是待定参数，<span class="math inline">\(\mathbf{N} _i\)</span>
是被称为试探函数（或基函数、形函数）的已知函数，它取自<strong>完全的函数序列</strong>，是线性独立的。近似解通常选择使之满足强制边界条件和连续性的要求。</p>
<blockquote>
<p>完全函数序列：任一函数都可以用此序列表示。</p>
</blockquote>
<p>显然，试探函数为有限项时，近似解是不能精确满足微分方程和边界条件的，它们将产生<strong>残差</strong>
<span class="math inline">\(\mathbf{R}\)</span> 和 <span
class="math inline">\(\bar{\mathbf{R}}\)</span>。</p>
<p><span class="math display">\[
\mathbf{A}(\mathbf{Na}) = \mathbf{R}
\]</span></p>
<p><span class="math display">\[
\mathbf{B}(\mathbf{Na}) = \bar{\mathbf{R}}
\]</span></p>
<p>残差 <span class="math inline">\(\mathbf{R}\)</span> 和 <span
class="math inline">\(\bar{\mathbf{R}}\)</span>
也被称为余量。将原方程写作等效积分形式，并用 <span
class="math inline">\(n\)</span> 个规定的函数代替任意函数 <span
class="math inline">\(\mathbf{v}\)</span> 和 <span
class="math inline">\(\bar{\mathbf{v}}\)</span>：</p>
<p><span class="math display">\[
\mathbf{v}=\mathbf{W} _j, \quad \bar{\mathbf{v}}=\bar{\mathbf{W}} _j
\quad (j=1,2,\dots,n)
\]</span></p>
<p>则原微分方程的等效形式变为：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{W} _j ^\mathrm{T} \mathbf{A}(\mathbf{Na})
\mathrm{d} \Omega + \int _\Gamma \bar{\mathbf{W}} _j ^\mathrm{T}
\mathbf{B}(\mathbf{Na}) \mathrm{d} \Gamma  = 0
\]</span></p>
<p>亦可写为余量形式：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{W} _j ^\mathrm{T} \mathbf{R} \mathrm{d} \Omega +
\int _\Gamma \bar{\mathbf{W}} _j ^\mathrm{T} \bar{\mathbf{R}} \mathrm{d}
\Gamma  = 0
\]</span></p>
<p>也可写出等效积分弱形式：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{C} ^\mathrm{T} (\mathbf{W} _j)
\mathbf{D}(\mathbf{Na}) \mathrm{d} \Omega + \int _\Gamma \mathbf{E}
^\mathrm{T} (\bar{\mathbf{W}} _j) \mathbf{F}(\mathbf{Na}) \mathrm{d}
\Gamma  \equiv 0
\]</span></p>
<p>以上三式的意义是：通过选择待定系数 <span
class="math inline">\(\mathbf{a} _i\)</span>
，强迫余量在某种平均意义上等于零。<span class="math inline">\(\mathbf{W}
_j\)</span> 和 <span class="math inline">\(\bar{\mathbf{W}} _j\)</span>
称为权函数。
余量的加权积分为零就得到了一组求解方程，用以求解近似解的待定系数 <span
class="math inline">\(\mathbf{a}\)</span>，从而得到原问题的近似解答。</p>
<p>近似函数所取的试探函数的项数越多，近似解的精度越高。当项数趋于无穷时，近似解将收敛于精确解。</p>
<p>取 <span class="math inline">\(\mathbf{W} _j= \mathbf{N}
_j\)</span>，在边界上 <span class="math inline">\(\bar{\mathbf{W}} _j=
-\mathbf{W} _j = -\mathbf{N}
_j\)</span>。即简单的利用近似解的试探函数序列作为权函数时，以上步骤称为<strong>加权残值伽辽金法</strong>。此时有：</p>
<p><span class="math display">\[
\int _\Omega \mathbf{N} _j ^\mathrm{T} \mathbf{A}\left( \sum ^n
_{i=1}\mathbf{N} _i \mathbf{a} _i  \right) \mathrm{d} \Omega + \int
_\Gamma \bar{\mathbf{N}} _j ^\mathrm{T} \mathbf{B}\left( \sum ^n
_{i=1}\mathbf{N} _i \mathbf{a} _i \right) \mathrm{d} \Gamma  = 0
\]</span></p>
<h3 id="加权残值伽辽金法的特点">加权残值伽辽金法的特点</h3>
<p><strong>特点：如果算子 <span
class="math inline">\(\mathbf{A}\)</span>
是线性自伴随的，则采用伽辽金法得到的求解方程的系数矩阵是对称的。</strong>
在高维问题中，这种对称性会大大减少计算量。因此使用加权残值法建立有限元格式时，几乎毫无例外地采用伽辽金法。现以一维热传导问题为例说明该特点。</p>
<p>在一维热传导问题中，如果热传导系数取1，则微分方程为：</p>
<p><span class="math display">\[
A(\phi) = \frac{\mathrm{d}^2 \phi}{\mathrm{d} x^2}+Q(x) = 0 \quad (0
\leq x \leq L)
\]</span></p>
<p>其中，当 <span class="math inline">\(0\leq x\leq \frac{L}{2}\)</span>
时 <span class="math inline">\(Q(x)=1\)</span> ；当 <span
class="math inline">\(\frac{L}{2}\leq x\leq L\)</span> 时 <span
class="math inline">\(Q(x)=0\)</span>。 边界条件为 <span
class="math inline">\(x=0\)</span> 和 <span
class="math inline">\(x=L\)</span> 时，<span class="math inline">\(\phi
=0\)</span>。</p>
<p>取傅里叶级数作为近似解：</p>
<p><span class="math display">\[
\phi \approx \tilde{\phi} = \sum ^n _{i=1} a _i \sin \frac{i\pi x}{L}
\]</span></p>
<p>其中 <span class="math inline">\(a_i\)</span> 为待定参数，试探函数
<span class="math inline">\(N_i= \sin \frac{i\pi
x}{L}\)</span>。近似解满足边界条件，因此在边界上不产生余量。将近似解带入原方程的等效积分形式中：</p>
<p><span class="math display">\[
\int ^L _0 W _j \left[ \frac{\mathrm{d}^2}{\mathrm{d} x^2} \left( \sum
^n _{i=1} N _i a _i \right) +Q \right] \mathrm{d} x=0 \quad
(j=1,2,\dots,n)
\]</span></p>
<p>采用伽辽金法时，因为权函数 <span class="math inline">\(W _j = N
_j\)</span> 是连续的，并且在两端等于 <span class="math inline">\(N _j
=0\)</span>。对上式分部积分可以得到等效积分形式的弱形式：</p>
<p><span class="math display">\[
\int ^L _0 \left[ \frac{\mathrm{d}W _j}{\mathrm{d}x}
\frac{\mathrm{d}}{\mathrm{d} x} \left( \sum ^n _{i=1} N _i a _i \right)
+ W _j Q \right] \mathrm{d} x=0 \quad (j=1,2,\dots,n)
\]</span></p>
<p>上式可以改写为：</p>
<p><span class="math display">\[
\mathbf{Ka-P=0}
\]</span></p>
<p>其中，<span class="math inline">\(\mathbf{P}\)</span> 和 <span
class="math inline">\(\mathbf{a}\)</span> 是 <span
class="math inline">\(n\)</span> 维向量</p>
<p><span class="math display">\[
P _j =\int ^L _0 W _j Q \mathrm{d}x
\]</span></p>
<p><span class="math display">\[
K _{ij} = \frac{\mathrm{d}W _i}{\mathrm{d}x} \frac{\mathrm{d} N
_j}{\mathrm{d} x}
\]</span></p>
<p>可以看到，当 <span class="math inline">\(W _i= N _i\)</span> 时，将有
<span class="math inline">\(K _{ij} = K
_{ji}\)</span>，换而言之，采用伽辽金法得到的求解待定参数 <span
class="math inline">\(a _i\)</span> 的代数方程组的系数矩阵 <span
class="math inline">\(\mathbf{K}\)</span> 是对称的。</p>
]]></content>
      <tags>
        <tag>有限元</tag>
      </tags>
  </entry>
  <entry>
    <title>最小势能原理与最小余能原理</title>
    <url>/2021/08/24/%E6%9C%80%E5%B0%8F%E5%8A%BF%E8%83%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BD%99%E8%83%BD%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最小势能原理和最小余能原理是物理和工程学中的基本概念，被应用于力学、电学、生物学等多种学科。</p>
<p>弹性力学有两种提法，一种微分提法，一种变分提法。微分提法从微元入手，得到严格满足方程和边界条件的强解；变分提法从整体（能量）入手，得到<a
href="https://en.wikipedia.org/wiki/Weak_solution">弱解</a>。最小势能原理和最小余能原理是为后者服务的，它们从能量入手，为一些经典方法的提出奠定了理论基础，如Galerkin（伽辽金）方法、Rayleigh–Ritz（瑞利-里兹）方法等。本文只讨论弹性力学中的最小势能原理与最小余能原理。</p>
<p>为了阐明这两种原理及其关系，需要引入一些概念：<strong>运动许可状态、静力许可状态、虚位移、虚力、系统的总势能、系统的总余能、应变能密度、余应变能密度、可能功原理</strong>。</p>
<h2 id="相关概念的引入">相关概念的引入</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><strong>运动许可状态：</strong>
满足位移约束条件的（可能存在的）状态。相应的变分是虚位移。</li>
<li><strong>静力许可状态：</strong>
满足平衡方程和力边界条件的（可能存在的）状态。相应的变分是虚力。</li>
<li><strong>虚位移：</strong>
给定的瞬时和位形上，虚位移是符合约束条件的无穷小位移。</li>
<li><strong>虚力：</strong>
给定的瞬时和位形上，虚力是符合平衡方程和力边界条件的的无穷小力。</li>
<li><strong>总势能 <span class="math inline">\(\Pi\)</span>：</strong>
等于应变能+外力势（<span class="math inline">\(\Pi=U+W\)</span>）</li>
<li><strong>总余能 <span class="math inline">\(\Pi^*\)</span>：</strong>
等于余应变能+外力余势（<span class="math inline">\(\Pi ^ * = U ^ *+ W ^
*\)</span>）</li>
</ul>
<p>应变能、余应变能、外力势、外力余势的概念见下一节</p>
<h3 id="应变能和余应变能">应变能和余应变能</h3>
<p><strong>应变能：</strong>
弹性体受外力作用产生应变，产生应力场和位移场。外力对弹性体所做的功以变形能的形式储存在弹性体内，这种变形能通常称为应变能。</p>
<p>现以杆件的拉伸问题为例介绍<strong>应变能</strong>和<strong>余应变能</strong>的概念。如下图(a)所示，杆件原长为
<span class="math inline">\(l\)</span>，伸长量为 <span
class="math inline">\(u=\varepsilon l\)</span>，受到一个平行于杆件的静力
<span class="math inline">\(P=\sigma f\)</span>，<span
class="math inline">\(f\)</span> 为横截面积。</p>
<p><img src="/image/FiniteElement/yingbianneng.png" width = "90%" height = "90%"  align=center /></p>
<p>此时，外力 <span class="math inline">\(P\)</span>
所做的功所引起的势能损失为图(b)中曲线下半部分面积 <span
class="math inline">\(W\)</span>，被称为<strong>外力势</strong>(外载荷的势能)：</p>
<p><span class="math display">\[
W= -\int _0^u P \mathrm{d} u = -fl \int _0^\varepsilon \sigma \mathrm{d}
\varepsilon
\]</span></p>
<blockquote>
<p>上式中的正负号表示外力所做的功引起的系统势能的增减，此时外力方向与位移方向相同，外力做正功，系统有势能损失，为负号。这可能不好理解，那么我们考虑重力对物体的影响。当一个重物被抬升一段距离，此时系统势能增加，重力做负功。即外力方向与位移方向相反，外力做负功，系统势能增加。</p>
</blockquote>
<p>画出系统的应力应变曲线图(c)，则上式左端</p>
<p><span class="math display">\[
A = \int _0^\varepsilon \sigma \mathrm{d} \varepsilon
\]</span></p>
<p>代表单位体积下的应变势能，定义为<strong>应变能密度</strong>。则系统的<strong>应变能</strong>
<span class="math inline">\(U\)</span> 为：</p>
<p><span class="math display">\[
U= \int _V A \mathrm{d}V = fl \int _0^\varepsilon \sigma \mathrm{d}
\varepsilon
\]</span></p>
<p>与应变能相对的是<strong>余应变能</strong>。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">应变能 <span
class="math inline">\(U\)</span></th>
<th style="text-align: center;">余应变能 <span
class="math inline">\(U^*\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">应变能密度 <span
class="math inline">\(A\)</span></td>
<td style="text-align: center;">余应变能密度 <span
class="math inline">\(B\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">外力势 <span
class="math inline">\(W\)</span></td>
<td style="text-align: center;">外力余势 <span
class="math inline">\(W^*\)</span></td>
</tr>
</tbody>
</table>
<p><strong>余应变能密度</strong> <span class="math inline">\(B\)</span>
对应图(c)上半部分面积：</p>
<p><span class="math display">\[
B = \int _0^\sigma \varepsilon  \mathrm{d} \sigma
\]</span></p>
<p>则系统的<strong>余应变能</strong> <span
class="math inline">\(U^*\)</span> 为：</p>
<p><span class="math display">\[
U= \int _V B \mathrm{d}V = fl \int _0^\sigma \varepsilon  \mathrm{d}
\sigma
\]</span></p>
<p><strong>外力余势</strong> <span class="math inline">\(W^*\)</span>
对应图(b)上半部分面积:</p>
<p><span class="math display">\[
W^* = -\int _0^P u \mathrm{d} P
\]</span></p>
<p>外力余势通常在支撑部分。</p>
<p><strong>应变能与余应变能之间的关系：</strong></p>
<p><span class="math display">\[
A+B = \int _V \sigma \varepsilon \mathrm{d} V
\]</span></p>
<h3 id="可能功原理">可能功原理</h3>
<p>考虑弹性体的两个状态，状态一是应力许可的，状态二是运动许可的。</p>
<p>利用上标 <span class="math inline">\(s\)</span> 表示状态一（<span
class="math inline">\(f _i\)</span> 为体力，<span
class="math inline">\(p _i\)</span> 为面力）</p>
<p><span class="math display">\[
\sigma _{ij,j}^{(s)}+ f _i^{(s)}=0
\]</span></p>
<p><span class="math display">\[
\sigma _{ij}^{(s)} v _j =p _i^{(s)}
\]</span></p>
<p>利用上标 <span class="math inline">\(k\)</span> 表示状态二</p>
<p><span class="math display">\[
\varepsilon _{ij}^{(k)} = \frac{1}{2} \left( u _{i,j}^{(k)} + u
_{j,i}^{(k)} \right)
\]</span></p>
<p>考虑状态一中的体力、面力和可能应力在状态二的相应可能位移和可能应变上所做的功，分别为：</p>
<p><span class="math display">\[
A _f = \int _V f _i^{(s)} u _i^{(k)} \mathrm{d} V
\]</span></p>
<p><span class="math display">\[
A _p = \int _S p _i^{(s)} u _i^{(k)} \mathrm{d} S = \int _S \sigma
_{ij}^{(s)}  u _i^{(k)} v _j  \mathrm{d} S = \int _V \left( \sigma
_{ij}^{(s)}  u _i^{(k)} \right) _{,j}\mathrm{d} V = \int _V  \sigma
_{ij,j}^{(s)}  u _i^{(k)}  \mathrm{d} V  +\int _V  \sigma _{ij}^{(s)}  u
_{i,j}^{(k)}  \mathrm{d} V
\]</span></p>
<p><span class="math display">\[
A _\sigma = \int _V \sigma _{ij}^{(s)} \varepsilon _{ij}^{(k)}
\mathrm{d} V
\]</span></p>
<p><strong>可能功原理：</strong>
外力功等于内力功，状态一的外力在状态二位移做的功等于状态一的应力在状态二的应变上做的功。</p>
<p><strong>物理意义：</strong>
外力与内力构成自平衡力系，他们在可能位移上做的总功为零。
<strong>适用性：</strong>
静力可能状态和几何可能状态时完全独立的；与本构关系无关，适用于任何连续介质</p>
<p>推导过程如下：</p>
<p><span class="math display">\[
A _p    = \int _V  \sigma _{ij,j}^{(s)}  u _i^{(k)}  \mathrm{d} V  +\int
_V  \sigma _{ij}^{(s)}  u _{i,j}^{(k)}  \mathrm{d} V = \int _V f
_i^{(s)} u _i^{(k)}  \mathrm{d} V + \int _V  \sigma
_{ij}^{(s)}  \varepsilon _{ij}^{(k)}   \mathrm{d} V = -A _f +A _\sigma
\]</span></p>
<p><span class="math display">\[
A _f +  A _p  =  A _\sigma
\]</span></p>
<p><span class="math display">\[
\int _V f _i^{(s)} u _i^{(k)} \mathrm{d} V + \int _S p _i^{(s)} u
_i^{(k)} \mathrm {d} S = \int _V \sigma _{ij}^{(s)} \varepsilon
_{ij}^{(k)} \mathrm{d} V
\]</span></p>
<h2 id="最小势能原理">最小势能原理</h2>
<h3 id="原理简述">原理简述</h3>
<p><strong>最小势能原理：</strong>
在满足弹性体的几何方程和位移边界条件的所有容许的位移中，真实的位移必使弹性体的总势能有驻值。当弹性体为稳定平衡时，其总势能为极小值。</p>
<p><strong>简述为：在一切运动许可状态中，真实状态的总势能最小。</strong></p>
<h3 id="原理推导">原理推导</h3>
<p>图中是一个一般意义下的弹性体。受到的外力分为面力 <span
class="math inline">\(\bar{p} _i\)</span> 和体力 <span
class="math inline">\(f _i\)</span>；弹性体的外表面 <span
class="math inline">\(S _u\)</span> 所在区域受到位形约束 <span
class="math inline">\(\bar{u} _i\)</span>。</p>
<p><span class="math display">\[
\varepsilon _{i j}=\frac{1}{2}\left(u _{i, j}+u _{j, i}\right)
\]</span></p>
<p><span class="math display">\[
\sigma _{i j, j}+f _{i}=0
\]</span></p>
<p><span class="math display">\[
\sigma _{i j} v _{i}=\bar{p} _{j} \quad \text { on } S _{\sigma}
\]</span></p>
<p><span class="math display">\[
u _{i}= \bar{u} _{i} \quad \text { on } S _{u}
\]</span></p>
<p><span class="math display">\[
\sigma _{i j}=\frac{\partial A\left(\varepsilon _{i j}\right)}{\partial
\varepsilon _{i j}}
\]</span></p>
<p><img src="/image/FiniteElement/shinengyuanli.png" width = "60%" height = "60%"  align=center /></p>
<p><strong>真实状态</strong>的总势能 <span
class="math inline">\(\Pi\)</span> 分为应变能 <span
class="math inline">\(U\)</span> 和 外力势 <span
class="math inline">\(W\)</span> 两部分：</p>
<p><span class="math display">\[
\Pi = U+W = \int _{V} A \left( \varepsilon _{i j} \right) \mathrm{d} V-
\left( \int _{V} f _{i} u _{i} \mathrm{d} V+\int _{S _{\sigma}} \bar{p}
_{i} u _{i} \mathrm{d} S \right)
\]</span></p>
<p>其中 <span class="math inline">\(A(\varepsilon_{ij})\)</span>
为应变能密度。</p>
<p><strong>运动许可状态</strong>由 <span
class="math inline">\(\varepsilon _{ij} ^{(k)}\)</span> 和 <span
class="math inline">\(u _{i} ^{(k)}\)</span> 描述，仅满足变形关系：</p>
<p><span class="math display">\[
\varepsilon_{i j}^{(k)}=\frac{1}{2}\left(u_{i, j}^{(k)}+u_{j,
t}^{(k)}\right), \quad u_{i}^{(k)}=\bar{u}_{i}
\]</span></p>
<p>运动许可状态的总势能为：</p>
<p><span class="math display">\[
\Pi^{(k)}=\int _{V} A^{(k)}\left(\varepsilon _{i j}^{(k)}\right)
\mathrm{d} V-\int _{V} f _{i} u _{i}^{(k)} \mathrm{d} V-\int _{S
_{\sigma}} \bar{p} _{i} u _{i}^{(k)} \mathrm{d} S
\]</span></p>
<p>两种状态的总势能差为：</p>
<p><span class="math display">\[
\begin{aligned}
\Pi^{(k)}-\Pi &amp;=\int_{V}\left[A^{(k)}\left(\varepsilon_{i
j}^{(k)}\right)-A\left(\varepsilon_{i j}\right)\right] \mathrm{d} V \\
&amp;-\int_{V} f_{i}\left[u_{i}^{(k)}-u_{i}\right] \mathrm{d} V-\int_{S}
p_{i}\left[u_{i}^{(k)}-u_{i}\right] \mathrm{d} S
\end{aligned}
\]</span></p>
<p>注意到与面力相关项的积分区域 <span class="math inline">\(S_\sigma
\rightarrow S\)</span>，这是因为两种状态都满足位形约束，所以两种状态在
<span class="math inline">\(S _u\)</span> 的位移差恒为0。</p>
<p>利用可能功原理，外力项可以被改写为：</p>
<p><span class="math display">\[
-\int_{V} f_{i}\left[u_{i}^{(k)}-u_{i}\right] \mathrm{d} V-\int_{S}
p_{i}\left[u_{i}^{(k)}-u_{i}\right] \mathrm{d} S =-\int_{V} \sigma_{i
j}\left(\varepsilon_{i j}^{(k)}-\varepsilon_{i j}\right) \mathrm{d}
V=-\int_{V} \frac{\partial A}{\partial \varepsilon_{i
j}}\left(\varepsilon_{i j}^{(k)}-\varepsilon_{i j}\right) \mathrm{d} V
\]</span></p>
<p>则两种状态的势能差为：</p>
<p><span class="math display">\[
\Pi^{(k)}-\Pi=\int_{V}\left[A^{(k)}\left(\varepsilon_{i
j}^{(k)}\right)-A\left(\varepsilon_{i j}\right) - \frac{\partial
A}{\partial \varepsilon_{i j}}\left(\varepsilon_{i
j}^{(k)}-\varepsilon_{i j}\right)\right] \mathrm{d} V
\]</span></p>
<p>只要应变能密度函数 <span class="math inline">\(A\)</span>
是凸函数，则必有：</p>
<p><span class="math display">\[
\Pi^{(k)}-\Pi \geq 0
\]</span></p>
<p>最小势能原理的变分形式：</p>
<p><span class="math display">\[
\delta \Pi=0
\]</span></p>
<p><span class="math display">\[
\delta \Pi=\delta U+\delta V=\delta \int _{V} A \mathrm{d} V-\int _{V} f
_{i} \delta u _{i} \mathrm{d} V-\int _{S _{\sigma}} \bar{p} _{i} \delta
u _{i} \mathrm{d} S
\]</span></p>
<p><span class="math display">\[
\delta U=-\delta V=\int _{V} f _{i} \delta u _{i} \mathrm{d} V+\int _{S
_{\sigma}} \bar{p} _{i} \delta u _{i} \mathrm{d} S
\]</span></p>
<h2 id="最小余能原理">最小余能原理</h2>
<h3 id="原理简述-1">原理简述</h3>
<p><strong>最小势能原理：</strong>
在弹性体内满足平衡微分方程，在应力边界上满足应力边界条件的所有容许的应力状态中，真实的应力状态（满足变形协调条件的应力）必使其总余能为极小值。</p>
<p><strong>简述为：在一切静力许可状态中，真实状态的总余能最小。</strong></p>
<h3 id="原理推导-1">原理推导</h3>
<p>还是考虑上图中的弹性体，应变可以用余应变能 <span
class="math inline">\(B\)</span> 表示：</p>
<p><span class="math display">\[
\varepsilon_{i j}=\frac{\partial B\left(\sigma_{i j}\right)}{\partial
\sigma_{i j}}
\]</span></p>
<p><strong>真实状态</strong>的系统总余能 <span
class="math inline">\(\Pi^*\)</span> 由 余应变能 <span
class="math inline">\(U^*\)</span> 和外力余势 <span
class="math inline">\(W^*\)</span> 构成：</p>
<p><span class="math display">\[
\Pi ^*= U^* +W^* \int_{V} B \left(\sigma_{i j}\right) \mathrm{d}
V-  \int_{S_{u}} p_{i} \bar{u}_{i} \mathrm{~d} S
\]</span></p>
<p><strong>静力许可状态</strong>仅满足静力关系：</p>
<p><span class="math display">\[
\sigma _{i j, j}^{(s)}+f _{i}=0 \quad \text{ on } V
\]</span></p>
<p><span class="math display">\[
p_{i}^{(s)}=\sigma_{i j}^{(s)} v_{j} \quad \text{ on } S _u
\]</span></p>
<p><span class="math display">\[
p_{i}^{(s)}=\bar{p}_{i}\quad \text{ on } S _\sigma
\]</span></p>
<p>静力许可状态的总余能为：</p>
<p><span class="math display">\[
\Pi ^{*(s)}= \int_{V} B^{(s)}\left(\sigma_{i j}^{(s)}\right) \mathrm{d}
V- \int_{S_{u}} p_{i}^{(s)} \bar{u}_{i} \mathrm{~d} S
\]</span></p>
<p>两种状态的势能差为：</p>
<p><span class="math display">\[
\Pi^{* (s)}-\Pi^*= \int _{V}\left[B^{(s)} \left( \sigma _{ij}^{(s)}
\right)-B\left(\sigma _{i j}\right)\right] \mathrm{d} V -\int
_{V}\left(f _{i}^{(s)}-f _{i}\right) u _{i} \mathrm{d} V-\int
_{S}\left(p _{i}^{(s)}-p _{i}\right) u _{i} \mathrm{d} S
\]</span></p>
<p>利用可能功原理，外力项可以被改写为：</p>
<p><span class="math display">\[
-\int _{V} \left( f _{i}^{(s)}-f _{i}\right) u _{i} \mathrm {d} V-\int
_{S}\left(p _{i}^{(s)}-p _{i}\right) u _{i} \mathrm {d} S=-\int _{V}
\varepsilon _{i j} \left( \sigma _{i j}^{(s)}-\sigma _{i j}\right)
\mathrm {d} V =-\int _{V} \frac {\partial B}{\partial \sigma _{i
j}}\left(\sigma _{i j}^{(s)}-\sigma _{i j}\right) \mathrm {d} V
\]</span></p>
<p>只要应变余能密度函数 <span class="math inline">\(B\)</span>
是凸函数，则必有：</p>
<p><span class="math display">\[
\Pi^{* (s)}-\Pi^* \geq 0
\]</span></p>
<h2
id="最小势能原理和最小余能原理的区别与联系">最小势能原理和最小余能原理的区别与联系</h2>
<p><strong>联系：</strong></p>
<p><span class="math display">\[
\Pi+\Pi^* =\int _{V} \left[ A+B \right] \mathrm{d} V-\int _{V} f _{i} u
_{i} \mathrm{d} V-\int _{S _{\sigma}} \bar{p} _{i} u _{i} \mathrm{d}
S-\int _{S _{u}} p _{i} \bar{u} _{i} \mathrm{d} S =\int _{V} \sigma _{i
j} \varepsilon _{i j} \mathrm{d} V-\int _{V} f _{i} u _{i} \mathrm{d}
V-\int _{S} p _{i} u _{i} \mathrm{d} S
\]</span></p>
<p>由可能功原理可得 <span class="math inline">\(\Pi
+\Pi^*=0\)</span>。</p>
<p>于是有:</p>
<p><span class="math display">\[
\Pi^{* (s)} \geq \Pi^* =-\Pi \geq - \Pi^{(k)}
\]</span></p>
<p>因此用这两种原理建立数值方程求解有如下<strong>特点：</strong> *
利用最小势能原理求得位移近似解的弹性变形能是精确解变形能的下届，即近似的位移场在总体上偏小，也就是说结构的计算模型显得偏于刚硬。
*
利用最小余能原理得到的近似解的弹性余能是精确余能的上界，即近似的应力解在总体上偏大，结构计算模型模型偏于柔软。
*
分别利用这两个极值原理求解同一个问题时，可以获得这个问题的上界和下界，可以较准确的估算所得近似解的误差。</p>
<p><strong>区别：</strong>
最小势能原理以位移为基本变量，要求位移场事先满足几何方程和给定位移边界条件。最小余能原理以应力为基本变量，要求应力场事先满足平衡方程和给定面力边界条件。</p>
<p>用这两个原理求解的优点是通常只有一个场函数，且泛函具有极值性。但是对于许多物理或力学问题，要求场函数事先满足全部附加条件是很困难的。</p>
<hr />
<p>参考： * <a href="https://en.wikipedia.org/wiki/Weak_solution">Weak
Solution - Wikipedia</a> * <a
href="https://zhuanlan.zhihu.com/p/26261872">弹性力学变分提法随记 -
知乎</a></p>
]]></content>
      <tags>
        <tag>有限元</tag>
        <tag>mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>通俗的理解何为变分</title>
    <url>/2021/08/24/%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BD%95%E4%B8%BA%E5%8F%98%E5%88%86/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>我们可以从微分的概念出发理解变分。</p>
<p><strong>微分</strong>：设有一个自变量 <span
class="math inline">\(x\in(a,b)\)</span> ，这个自变量的微小变化量记为
<span
class="math inline">\(\mathrm{d}x\)</span>，称为微分。此时我们关心的是，当自变量有微小变化
(<span class="math inline">\(\mathrm{d}x\)</span>) 时，函数 (<span
class="math inline">\(y(x)\)</span>) 变化了多少。</p>
<p><strong>变分</strong>：设有一个函数（泛函） <span
class="math inline">\(I=G(y,y^{\prime})\)</span>，其中 <span
class="math inline">\(y=y(x)\)</span>
是另一个函数（定义在某一个函数空间内是不确定的）。这个函数 <span
class="math inline">\(y\)</span> 的微小变化量记为 <span
class="math inline">\(\delta
y\)</span>，称为变分。此时我们关心的是，当函数 <span
class="math inline">\(y\)</span> 有微小变化时，函数（泛函） <span
class="math inline">\(I\)</span> 变化了多少。</p>
<p>简而言之，变分就是微分在函数空间的拓展，其精神内涵是一致的。</p>
<blockquote>
<p><strong>泛函</strong>：是将函数空间（无限维空间）映射到数域，就是把一个函数映射成一个数。打个比方，从A点到B点有无数条路径，每一条路径都是一个函数。这无数条路径，每一条函数（路径）的长度都是一个数。从这无数个路径当中选一个路径最短或者最长的，就是求泛函的极值问题。</p>
</blockquote>
<h2 id="变分">变分</h2>
<p>假设我们有两个定点 <span class="math inline">\((a,p)\)</span> 和
<span class="math inline">\((b,p)\)</span>，连接这两点的任意曲线的方程
<span class="math inline">\(y=y(x)\)</span> 都将满足如下的边界条件：</p>
<p><span class="math display">\[
y(a)=p,\quad y(b)=q
\]</span></p>
<p>现在考虑如下形式的定积分：</p>
<p><span class="math display">\[
I=\int_{a}^{b} f\left(y, y^{\prime}\right) \mathrm{d} x
\]</span></p>
<p>其中 <span class="math inline">\(f(y, y^{\prime})\)</span> 是关于
<span class="math inline">\(y(x)\)</span> 和它的一阶导数 <span
class="math inline">\(y^{\prime}(x)\)</span>
的函数，在实际问题中，我们有时需要找到一个具体的 <span
class="math inline">\(y(x)\)</span> 使得 <span
class="math inline">\(I\)</span> 有极值。</p>
<p>注意在一般的极值问题中，我们考察的是自变量 <span
class="math inline">\(x\)</span> 的变化：<span
class="math inline">\(x\)</span>
取值多少时，函数会有极值。这个新问题的不同之处在于，我们考察的是函数
<span class="math inline">\(y(x)\)</span> 的变化：<span
class="math inline">\(y(x)\)</span> 是什么形式时，<span
class="math inline">\(I\)</span> 会有极值（<span
class="math inline">\(I\)</span> 称作函数 <span
class="math inline">\(y(x)\)</span>
的<strong>泛函</strong>）。然而这两类问题依然有共通之处：当 <span
class="math inline">\(I\)</span> 取极值时，对 <span
class="math inline">\(y(x)\)</span> 作微小的变化，<span
class="math inline">\(I\)</span> 在一级近似下应该保持不变。</p>
<p><img src="/image/FiniteElement/bianfen.png" width = "50%" height = "50%"  align=center /></p>
<p>如果 <span class="math inline">\(y(x)\)</span> 有微小改变 <span
class="math inline">\(\delta y(x)\)</span>（高大上叫法：<span
class="math inline">\(\delta y(x)\)</span> 称作函数 <span
class="math inline">\(y(x)\)</span> 的变分），那么 <span
class="math inline">\(f\left(y, y^{\prime}\right)\)</span>
的变化为：</p>
<p><span class="math display">\[
\delta f=\frac{\partial f}{\partial y} \delta y+\frac{\partial
f}{\partial y^{\prime}} \delta y^{\prime}
\]</span></p>
<p><span class="math inline">\(I\)</span> 相应的变化为：</p>
<p><span class="math display">\[
\delta I=\int_{a}^{b}\left[\frac{\partial f}{\partial y} \delta
y+\frac{\partial f}{\partial y^{\prime}} \delta y^{\prime}\right]
\mathrm{d} x
\]</span></p>
<p>方括号里的第二项可以改写成 <span class="math inline">\(\frac{\partial
f}{\partial y^{\prime}} \frac{\mathrm{d}(\delta y)}{\mathrm{d}
x}\)</span>，然后可以进行分部积分:</p>
<p><span class="math display">\[
\int_{a}^{b} \frac{\partial f}{\partial y^{\prime}} \delta y^{\prime}
\mathrm{d} x =\int_{a}^{b} \frac{\partial f}{\partial y^{\prime}}
\mathrm{d}(\delta y) = \frac{\partial f}{\partial y^{\prime}} \delta y
{\bigg|} _{a} ^{b} -\int _{a} ^{b} \delta y \frac{\mathrm{d}}{\mathrm{d}
x}\left(\frac{\partial f}{\partial y^{\prime}}\right) \mathrm{d} x
\]</span></p>
<p>由于 <span class="math inline">\(y(x)\)</span> 的边界条件固定，<span
class="math inline">\(\delta y(a)=\delta
y(b)=0\)</span>，所以分部积分出来的第一项为零，仅第二项有贡献。上式化简为：</p>
<p><span class="math display">\[
\delta I=\int_{a}^{b}\left[\frac{\partial f}{\partial
y}-\frac{\mathrm{d}}{\mathrm{d}x}\left(\frac{\partial f}{\partial
y^{\prime}}\right)\right] \delta y(x) \mathrm{d}x
\]</span></p>
<p>如果 <span class="math inline">\(I\)</span>
有极值，对任意满足边界条件的 <span class="math inline">\(\delta
y(x)\)</span> 都必须有 <span class="math inline">\(\delta
I=0\)</span>，这就要求：</p>
<p><span class="math display">\[
\frac{\partial f}{\partial y}-\frac{\mathrm{d}}{\mathrm{d}
x}\left(\frac{\partial f}{\partial y^{\prime}}\right)=0
\]</span></p>
<p>这便是 <strong>Euler-Lagrange
方程</strong>，它是变分法的核心定理。有了它，原则上就可以找出所寻求的极值函数
<span class="math inline">\(y(x)\)</span>。</p>
<blockquote>
<p>Euler-Lagrange
方程的应用：两点间最短路径问题、最速降曲线问题、悬链线等。</p>
</blockquote>
<hr />
<p>本文参考了以下博主分享的文章： * <a
href="https://zhuanlan.zhihu.com/p/139018146">浅谈变分原理</a> * <a
href="https://www.zhihu.com/question/30416914">微分、差分和变分的概念有什么异同？</a></p>
]]></content>
      <tags>
        <tag>有限元</tag>
      </tags>
  </entry>
  <entry>
    <title>压电加速度传感器基本原理</title>
    <url>/2021/06/13/2021-6-13-%E5%8E%8B%E7%94%B5%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="压电效应">压电效应</h2>
<p>某些电介质在沿一定方向上受到外力的作用而变形时，其内部会产生极化现象，同时在它的两个相对表面上出现正负相反的电荷。当外力去掉后，它又会恢复到不带电的状态，这种现象称为正压电效应。当作用力的方向改变时，电荷的极性也随之改变。依据电介质压电效应研制的一类传感器称为压电传感器。</p>
<h2 id="压电加速度传感器">压电加速度传感器</h2>
<p>压电式加速度传感器又称压电加速计。
<strong>工作原理</strong>：在加速度计受振时，质量块加在压电元件上的力也随之变化。当被测振动频率远低于加速度计的固有频率时，则力的变化与被测加速度成正比。压电式加速度传感器利用了某些物质的压电效应，可以将加在自身上的力转化为电荷的变化，即将机械信号转化为电信号，进而通过电信号的转化成功输出或储存被测物体的加速度信号。</p>
<p>设 <span class="math inline">\(q\)</span> 为释放的电荷，<span
class="math inline">\(F\)</span> 为作用力，<span
class="math inline">\(A\)</span> 为电极化面面积，<span
class="math inline">\(d_x\)</span> 是压电系数，单位为 <span
class="math inline">\(C/N\)</span>（库伦/牛），则下列关系式成立：</p>
<p><span class="math display">\[
\frac{q}{A}=d_x\frac{F}{A}
\]</span></p>
<p>理论与试验研究表明，在一般情况下，表示机械量和电量之间关系的压电方程是很复杂的，但是在压电材料弹性变形范围内，电荷与作用力之间的关系可以用线性映射关系表现出来:</p>
<p><span class="math display">\[
\bar{q}=\textbf{D}\bar{F}
\]</span></p>
<figure>
<img src="/image/zhendongceshi/yadianxiaoying1.jpg" alt="yadian" />
<figcaption aria-hidden="true">yadian</figcaption>
</figure>
<p>如上所示，压电型加速度传感器，基座受到的加速度最终会以电压形式输出。电荷及电压输出都与加速度成一定比例关系，因此通过测量电荷和电压即可得出加速度。一般电荷输出称为电荷灵敏度，电压输出称为电压灵敏度。</p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础知识</title>
    <url>/2021/11/09/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="数据类型">数据类型</h2>
<h3 id="字符-str">字符 str</h3>
<ul>
<li><strong>引号</strong>：在字符中显示单引号，则编程时用双引号将字符括起来；在字符中显示双引号，则编程时用单引号将字符括起来；
字符中的单引号：<code>course = "He's finger"</code>
字符串中的双引号：<code>words = 'Python is for "beginners"'</code></li>
<li><strong>大小写</strong>：<code>course.upper()</code> 、
<code>course.lower()</code>、<code>course.title()</code></li>
<li><strong>查找替换</strong>：<code>course.find('xxx'),</code>和<code>course.replace('xxx','aaa')</code></li>
<li><strong>字符长度</strong>：使用<code>len()</code></li>
<li><strong>f与花括号</strong>：可以被用来格式化输出字符（在字符中嵌入变量）。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first_name=&#x27;John&#x27;</span><br><span class="line">last_name=&#x27;Smith&#x27;</span><br><span class="line">msg = f&quot;&#123;first_name&#125; [&#123;last_name&#125;] is a coder&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>整数 int 浮点数 float 复数 complex</p>
<h3 id="数据索引">数据索引</h3>
<ol type="1">
<li>Python中的索引从0开始</li>
<li>数据索引中的负号表示从结束端开始：<code>[1:-1]</code>是正确的，-1表示倒数第二个数据</li>
</ol>
<p><strong>数据切片索引</strong>
与Matlab不同的是，<code>A[1:5]</code>返回的不是数列A中位于1、2、3、4、5号位置的数据；取而代之的是：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">print(A[1:5])</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">      -------------------------------------------</span><br><span class="line">[A]:   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |</span><br><span class="line">cut:  -0---1---2---3---4---5---6---7---8---9----10- </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="if">if</h2>
<p>常用调用模式如下，用缩进控制开始和结束（与matlab不同）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if is_hot:</span><br><span class="line">    print(&#x27;xxxxx&#x27;)</span><br><span class="line">elif is_coldL:</span><br><span class="line">    print(&#x27;xxxxxx&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;xxxx&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>常用逻辑运算符 1.
和：<code>and</code>，例如：<code>is_hot and is_cold</code> 1.
或：<code>or</code> 1.
非：<code>not</code>，例如：<code>is_cold and not is_wind</code>，<code>not</code>会将其后的False转化为True；上例中如果<code>is_cold = True</code>、<code>is_wind = False</code>，则返回<code>True</code></p>
<p>比大小： 1.
大于：<code>&gt;</code>、小于:<code>&lt;</code>、等于:<code>==</code> 1.
大于等于：<code>&gt;=</code>、小于等于：<code>&lt;=</code> 1.
不等于：<code>!=</code></p>
<h2 id="循环">循环</h2>
<p><code>while</code>常用调用模式如下，<code>break</code>可以用来跳出程序：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line">while i&lt;=5：</span><br><span class="line">    print(&#x27;i&#x27;)</span><br><span class="line">    i = i + 1</span><br><span class="line">print(&#x27;Done&#x27;) #用缩进控制while的结束</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>常用调用模式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for item in [1,2,3,4]</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数">函数</h2>
<h3 id="常用函数">常用函数</h3>
<p>绝对值：<code>abs()</code> 四舍五入到整数：<code>round()</code>
生成等间距数列：<code>range(5,10,2)</code>；step=2，from 5 to 10，输出 5
7 9</p>
<h2 id="常用命令">常用命令</h2>
<h3 id="运算符号">运算符号</h3>
<ol type="1">
<li>加<code>+</code>；减<code>-</code>；乘<code>*</code>；除<code>/</code>；幂<code>**</code></li>
<li>特殊除号：得到结果的整数部分<code>//</code>；得到结果的余数<code>%</code></li>
<li>增广运算符<code>X += 3</code>与<code>x = x + 3</code>等价、<code>x -= 3</code>同理</li>
</ol>
<h3 id="import"><strong><em>import</em></strong></h3>
<p>调用包：<code>import XXX</code>，例如<code>import math</code>;使用时<code>math.acos()</code></p>
<h2 id="questions">Questions</h2>
<ol type="1">
<li>methods 和 function 在Python有何区别的？</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>采样定理</title>
    <url>/2021/06/13/2021-6-13-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="采样">采样</h2>
<p>采样就是将连续模拟信号变为离散数字信号的过程。</p>
<h2 id="什么是采样定理">什么是采样定理</h2>
<p>离散后的信号能唯一的确定原连续信号，并要求离散信号通过D/A（数/模）转化后能恢复成原连续信号。由于离散信号是从连续信号上取出的一部分值，与连续信号的关系是整体和局部的关系，一般来说是不可能唯一确定连续信号的。只有在满足一定条件下，离散信号才可按照一定方式恢复出原来的连续信号。这个条件就是采样定理。</p>
<h2 id="如何满足采样定理">如何满足采样定理</h2>
<p><strong>采样定理</strong>：采样频率必须大于被分析信号成分中最高频率值的两倍以上，否则将产生高、低频<strong>混淆现象</strong>，即高频信号经采样后只出现低频信号，采样信号无法还原为原信号。
<span class="math display">\[
f_s=\frac{1}{\Delta t} &gt;2f_m
\]</span></p>
<p>其中<span class="math inline">\(f_s\)</span>是采样频率，<span
class="math inline">\(f_m\)</span>是被分析信号成分中的最高频率值，<span
class="math inline">\(\Delta t\)</span>是采样时间间隔。</p>
<h2 id="频率混淆现象">频率混淆现象</h2>
<p><strong>如果想彻底了解采样定理的内涵，以及为什么不满足采样定理就会出现混淆现象，请接着看下去</strong>
读者自己推导采样后得到的信号<span
class="math inline">\(x_s(t)\)</span>的傅里叶变换表达式<span
class="math inline">\(X_s(j\omega)\)</span>，再根据<span
class="math inline">\(X_s(j\omega)\)</span>绘制频谱图，最终就会理解采样定理的内涵。</p>
<p>为了便于推导，现定义： * 原信号：<span
class="math inline">\(x_m(t)\)</span>，傅里叶变换后为<span
class="math inline">\(X_m(j\omega)\)</span> * 采样函数：<span
class="math inline">\(s(t)\)</span>，傅里叶变换后为<span
class="math inline">\(S(j\omega)\)</span> * 采样后输出信号：<span
class="math inline">\(x_s(t)\)</span>，傅里叶变换后为<span
class="math inline">\(X_s(j\omega)\)</span></p>
<h3 id="采样函数st">采样函数<span
class="math inline">\(s(t)\)</span></h3>
<p>当我们把采样的过程看作一个周期为 <span
class="math inline">\(T\)</span> 、宽度为 <span
class="math inline">\(\tau\)</span> 的矩形脉冲信号<span
class="math inline">\(s(t)\)</span>。当<span
class="math inline">\(\tau\ll T\)</span> 时，采样脉冲信号<span
class="math inline">\(s(t)\)</span>具有了狄拉克<span
class="math inline">\(\delta\)</span>函数的性质：</p>
<p><span class="math display">\[
\delta(t)= \begin{cases} \infty &amp; t=0 \\\\ 0 &amp;      t\neq 0
\end{cases}
\]</span></p>
<p><span class="math display">\[
s(t)= \sum^\infty_{n=-\infty} \delta(t-nT)
\]</span></p>
<p>为了便于傅里叶变换，把<span
class="math inline">\(s(t)\)</span>表示为傅里叶级数的形式：</p>
<p><span class="math display">\[
s(t)=\sum^\infty_{k=-\infty} a_k e^{jk\omega_s t} ,\quad
\omega_s=\frac{2\pi}{T}
\]</span></p>
<p>其中：</p>
<p><span class="math display">\[
a_k=\frac{1}{T} \int^{T/2}_ {-T/2} \sum\nolimits^\infty_{n=-\infty}
\delta(t-nT) e^{-j\omega_s t} dt=\frac{1}{T}
\]</span></p>
<p>因此，有：</p>
<p><span class="math display">\[
s(t)=\frac{1}{T} \sum^\infty_{k=-\infty} e^{jk\omega_s t}
\]</span></p>
<p>对<span class="math inline">\(s(t)\)</span>进行傅里叶变换得到<span
class="math inline">\(S(j\omega)\)</span>：</p>
<p><span class="math display">\[
S(j\omega)=F \left[  s(t) \right] =F \left[  \frac{1}{T}
\sum^\infty_{k=-\infty} e^{jk\omega_s t}  \right]  = \frac{1}{T}
\sum^\infty_{k=-\infty} F \left[  e^{jk\omega_s t}  \right]
\]</span></p>
<p>查常用Fourier变换表可知：</p>
<p><span class="math display">\[
F \left[  e^{jk\omega_s t}  \right] =2\pi \delta(\omega -k\omega_s)
\]</span></p>
<p>则<span class="math inline">\(S(j\omega)\)</span>为：</p>
<p><span class="math display">\[
S(j\omega) = \frac{2\pi}{T} \sum^\infty_{k=-\infty} \delta(\omega
-k\omega_s)
\]</span></p>
<h3 id="采样后输出的信号x_st">采样后输出的信号<span
class="math inline">\(x_s(t)\)</span></h3>
<p>采样后输出的信号<span
class="math inline">\(x_s(t)\)</span>等于原信号<span
class="math inline">\(x_m(t)\)</span>乘采样函数<span
class="math inline">\(s(t)\)</span>：</p>
<p><span class="math display">\[
x_s(t)=x_m(t)s(t)
\]</span></p>
<p>记<span
class="math inline">\(*\)</span>为卷积，根据频域下的卷积定理</p>
<p><span class="math display">\[
f_1(t)f_2(t)=\frac{1}{2\pi}F^{-1}\left[ F_1(j\omega)*
F_2(j\omega)\right]
\]</span></p>
<p>采样后输出的信号<span
class="math inline">\(X_s(j\omega)\)</span>为：</p>
<p><span class="math display">\[
X_s(j\omega)=\frac{1}{2\pi} X_m(j\omega)*S(j\omega)=\frac{1}{2\pi}·
X_m(j\omega) *\left[ \frac{2\pi}{T} \sum^\infty_{k=-\infty}
\delta(\omega -k\omega_s) \right]
\]</span></p>
<p>根据冲击函数的性质有： <span class="math display">\[
X_s(j\omega)=\frac{1}{T} \int^\infty _ {-\infty} X_m(j\theta)
\sum^\infty_{k=-\infty} \delta(\omega -k\omega_s - \theta) d\theta
\]</span></p>
<blockquote>
<p>冲激函数的性质：<span
class="math inline">\(f(t)*\delta(t-t_0)=f(t-t_0)\)</span></p>
</blockquote>
<p>最终，采样后信号的傅里叶变换为：</p>
<p><span class="math display">\[
X_s(j\omega)=\frac{1}{T}\sum^\infty_{k=-\infty} X_m(j\omega-jk\omega_s)
\]</span></p>
<p>从上式可以看出，原信号的频谱<span
class="math inline">\(X_m(j\omega)\)</span>在频域内发生了周期延拓。即，原信号在频谱上的宽度是<span
class="math inline">\(2f_m\)</span>，每隔<span
class="math inline">\(f_s\)</span>重复一次（相当于信号的平移），发生了周期延拓，从图中直观的看出来，如果<span
class="math inline">\(f_s&lt;2f_m\)</span>，延拓后的信号会在频域内会发生混淆。</p>
<p><img src="/image/zhendongceshi/pinlvhunxiao.jpg" width = "60%" height = "60%"  align=center /></p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>质心_形心_重心</title>
    <url>/2022/03/08/%E8%B4%A8%E5%BF%83-%E5%BD%A2%E5%BF%83-%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<h2 id="三者存在的条件">三者存在的条件</h2>
<ul>
<li><strong>形心</strong>：目标具有几何外形；</li>
<li><strong>质心</strong>：目标具有几何外形、具有质量；</li>
<li><strong>重心</strong>：目标具有几何外形、具有质量、身处重力场。</li>
</ul>
<h2 id="质心">质心</h2>
<p><strong>定义</strong>：质心是多质点系统的质量中心。
<strong>特点</strong>：若对该点施力，系统会沿着力的方向运动、不会旋转。
<strong>质心位置</strong>：质点的位置对质量取加权平均值，求得质心位置。</p>
<p>对于离散系统，三维物体的质心位置由下式求得：</p>
<p><span class="math display">\[
\bar{x} = \frac{\sum{x_k m_k}}{\sum{m_k}}, \bar{y} = \frac{\sum{y_k
m_k}}{\sum{m_k}},  \bar{z} = \frac{\sum{z_k m_k}}{\sum{m_k}}
\]</span></p>
<p>对于连续系统，上式推广为： <span class="math display">\[
\bar{x} = \frac{\int_{\Omega}{x \rho} \rm{d}V}{\int_{\Omega}{ \rho}
\rm{d}V},  \bar{y} = \frac{\int_{\Omega}{y \rho} \rm{d}V}{\int_{\Omega}{
\rho} \rm{d}V}, \bar{z} = \frac{\int_{\Omega}{z
\rho}  \rm{d}V}{\int_{\Omega}{ \rho} \rm{d}V}
\]</span></p>
<p>其中，<span class="math inline">\(\rho\)</span> 是物体的密度，为
<span class="math inline">\(x,y,z\)</span> 的函数。上式为在物体所在空间
<span class="math inline">\(\Omega\)</span> 进行体积分。</p>
<h2 id="形心">形心</h2>
<p><strong>定义</strong>：形心又被称为几何中心。形心是将该物体分成“矩”相等的两部分的所有超平面的交点。
<strong>形心位置</strong>：等价于取加权平均。</p>
<p>对于二维图形，形心位置由下式给出： <span class="math display">\[
\bar{x} = \frac{\int{x f(x)}\rm{d}x}{\int{f(x)}\rm{d}x}, \bar{y} =
\frac{\int{y f(y)}\rm{d}y}{\int{f(y)}\rm{d}y}
\]</span></p>
<p>上式分子部分为 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的一阶矩。其中，<span
class="math inline">\(f(x)\)</span> 为几何图形的横坐标位于 <span
class="math inline">\(x\)</span> 点时在 <span
class="math inline">\(y\)</span> 方向上的长度；<span
class="math inline">\(f(y)\)</span> 为几何图形的纵坐标位于 <span
class="math inline">\(y\)</span> 点时在 <span
class="math inline">\(x\)</span> 方向上的长度。</p>
<p>上式的等价形式为： <span class="math display">\[
\bar{x} = \frac{\int_D{x}\rm{d}S}{\int_D{ }\rm{d}S} =
\frac{\int_D{x}\rm{d}S}{A}
\]</span></p>
<p>上式积分表示在几何图形所在二维空间 <span
class="math inline">\(D\)</span> 进行面积分；<span
class="math inline">\(A\)</span> 表示二维几何图形的面积。（<span
class="math inline">\(y\)</span> 方向写法与之类似）</p>
<p>将该式推广至三维空间可得： <span class="math display">\[
\bar{x} = \frac{\int_\Omega{x}\rm{d}V}{\int_\Omega{ }\rm{d}V} =
\frac{\int_\Omega{x}\rm{d}V}{V}
\]</span></p>
<p>对比发现，上式积分中如果加入密度项，则得到的质心的坐标。即，<strong>对于密度均匀的物体，其质心和形心重合</strong>。</p>
<h2 id="重心">重心</h2>
<p><strong>定义</strong>：重心是重力作用的平均位置。
<strong>特点</strong>：各质点相对于重心的位置矢量乘上各质点的重力之和(合力矩)为零。</p>
<p>在均匀的重力场中，重心等同于质心。在非均匀的重力场中，质心和重心往往不在同一点。</p>
]]></content>
      <tags>
        <tag>mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>Maple常用命令</title>
    <url>/2022/04/23/maple%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="基本操作">基本操作</h2>
<p><strong>赋值</strong>： <code>：=</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a :=b   #表示将 a 的值赋予 b</span><br></pre></td></tr></table></figure></p>
<p><strong>相等</strong>： <code>=</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b           # 创建了一个表达式</span><br><span class="line">equn:= a=b      #将表达式 a=b 赋值给 equn</span><br></pre></td></tr></table></figure></p>
<p><strong>执行但不输出结果</strong>： <code>:</code></p>
<p><strong>上标</strong>： <code>^</code></p>
<p><strong>下标</strong>： <code>__</code> （双下划线）</p>
<p><strong>乘</strong>： <code></code> （空格）</p>
<p><strong>构造矩阵</strong>： <code>&lt; &gt;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;a, b, c&gt; | &lt;x, y,z&gt;&gt;</span><br></pre></td></tr></table></figure>
输出结果为： <span class="math display">\[
\begin{bmatrix} a &amp; x \\\\ b &amp; y \\\\ c &amp; z \end{bmatrix}
\]</span></p>
<p><strong>构造函数</strong> <code>F:=x-&gt;2*x</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F := (x, y) -&gt; 2*x + y</span><br><span class="line">F(2,1)</span><br></pre></td></tr></table></figure>
输出结果为 <code>4</code></p>
<h2 id="最常用的数据类型">最常用的数据类型</h2>
<p><strong>序列</strong>： <code>a := 1, 2, 3</code>
特点：有顺序、可组合 <code>b:=a,4,5</code> （输出结果为
<code>1,2,3,4,5</code>），典型应用是函数的输入参数 生成序列的函数
<code>seq()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq(x^i,i=1..11,2)</span><br></pre></td></tr></table></figure> 输出结果为： <span
class="math inline">\(x,x^3,x^5,x^9,x^{11}\)</span></p>
<p><strong>列表</strong>： 是用 <code>[  ]</code> 封装的序列
与序列的不同：列表中嵌入列表展开方式不同
与集合的不同：列表中元素项顺序是固定的，且会保留重复项 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:=[1,2,3]:</span><br><span class="line">b:=[a,4,5]</span><br><span class="line">b[1]</span><br><span class="line">b[2]</span><br></pre></td></tr></table></figure>
输出结果为：<code>b:=[[1,2,3],4,5]</code> 和 <code>[1,2,3]</code> 和
<code>4</code></p>
<h2 id="表达式的处理">表达式的处理</h2>
<p><strong>简化</strong>： <code>simplify()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">equn :=a (a+b+2 a)</span><br><span class="line">simplify(equn)                          #处理单个表达式或矩阵</span><br><span class="line">equns := a (a+b+2 a), x+3x+y, m+n+n+n   #生成表达式序列</span><br><span class="line">simplify(equns)                         #会报错</span><br><span class="line">seq( simplify(equns[i]), i=1..3 )       #正常化简，生成一个化简后的序列</span><br><span class="line">simplify([equns])                       #正常化简，生成一个化简后的列表</span><br></pre></td></tr></table></figure></p>
<p><strong>展开</strong>： <code>expand()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:= x ( x+2 + x (x+3) )</span><br><span class="line">expand(a)                               #结果为 x^3 + 4*x^2 + 2*x</span><br><span class="line">b:= x ( x+2 + x (x+3) ), 2 y ( y+21 - 5 y (y+1) )</span><br><span class="line">expand(b)                               #只展开前一项，后一项被当作输入参数</span><br><span class="line">seq(expand(b[i]),i=1..2)                #正常展开，结果为序列 x^3 + 4*x^2 + 2*x, -10*y^3 - 8*y^2 + 42*y</span><br><span class="line">expand([b])                             #正常展开，结果为列表 [x^3 + 4*x^2 + 2*x, -10*y^3 - 8*y^2 + 42*y]</span><br></pre></td></tr></table></figure></p>
<p><strong>整理</strong>：<code>collect()</code> 和 <code>sort()</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">equn := x*y*(x + y*(x + y + y*(x^2 + 1)))</span><br><span class="line">equn := expand(equn)            #先展开 结果为 x^3*y^3 + x^2*y^2 + 2*x*y^3 + x^2*y</span><br><span class="line">collect(equn, y)                #再按照 y 整理各项，结果为 (x^3 + 2*x)*y^3 + x^2*y^2 + x^2*y</span><br><span class="line">sort(equn, y, ascending)        #按 y 降次排列，结果为 x^2*y + x^2*y^2 + x^3*y^3 + 2*x*y^3</span><br></pre></td></tr></table></figure></p>
<p><strong>变量替换</strong>：<code>subs()</code> 和
<code>algsubs()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := x + 3*y</span><br><span class="line">subs(x = z, a)          #用 z 替换表达式 a 中的 x，结果为 z + 3*y</span><br><span class="line">subs(z = x, a)          #因等式中无 z，故结果为 x + 3*y；等式左端为表示中已有变量，右端为替换后的变量</span><br><span class="line">subs（x = 2 z,a）       #结果为 2*z + 3*y</span><br><span class="line">subs（2 y = z,a）       #结果为 x + 3*y；因为subs只用来替换单变量不进行表达式的计算，该情况使用 algsubs()</span><br><span class="line">algsubs(2*y = z, a)     #结果为 x + (3*z)/2</span><br></pre></td></tr></table></figure></p>
<p><strong>微分</strong>： <code>diff()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般求导--------------------------------------------------------</span><br><span class="line">equn:=x^3 + 2*x*y^2 + x*y + y^2 + x</span><br><span class="line">diff(equn,x)                    #对 equn 关于 x 求导数，结果为 3*x^2 + 2*y^2 + y + 1</span><br><span class="line"># 对 x(t) 求导----------------------------------------------------</span><br><span class="line">equn2：= x(t) +x(t)^2</span><br><span class="line">diff(equn3, t)                  #可以对 t 直接求导，结果为diff(x(t), t) + 2*x(t)*diff(x(t), t)</span><br><span class="line">diff(equn2,x)                   #结果为0，因为maple不会将 x(t) 认定为 x</span><br><span class="line">diff(equn2, x(t))               #报错，不能对 x(t) 直接求导</span><br><span class="line">equn3 := subs(x(t) = x, equn3)  #先用 x 代换 x(t)，再求导</span><br><span class="line">equn3 := diff(equn3, x)</span><br><span class="line">equn3 := subs(x = x(t), equn3)  #再反代换回去，结果为 2*x(t) + 1</span><br></pre></td></tr></table></figure></p>
<p><strong>积分</strong>：<code>int()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integrand:= x+x^2</span><br><span class="line">int(integrand, x = 0 .. 1)      #被积函数是 integrand，积分下限是0，上限是1</span><br></pre></td></tr></table></figure></p>
<p><strong>选择特定项并移除</strong>： <code>select()</code> 和
<code>remove()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integers := [seq(10 .. 20)]     #结果为 [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span><br><span class="line">select(isprime, integers)       #选择列表 integers 里的质数，结果为[11, 13, 17, 19]</span><br><span class="line">remove(isprime, integers)       #移除列表 integers 里的质数，结果为[10, 12, 14, 15, 16, 18, 20]</span><br></pre></td></tr></table></figure></p>
<p><strong>解方程</strong>： <code>solve()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># solve() 的输入参数可以是序列或列表-------------------------------</span><br><span class="line">equns1 := x + y + z = 3:</span><br><span class="line">equns2 := 2*x + 4*y + z = 7:</span><br><span class="line">equns3 := x + y + 3*z = 5:</span><br><span class="line">equns := [equns1, equns2, equns3]:</span><br><span class="line">vars := [x, y, z]:</span><br><span class="line">solve(equns, vars)     #结果为 [[x = 1, y = 1, z = 1]]</span><br></pre></td></tr></table></figure></p>
<p><strong>转换</strong>： <code>convert()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integers:=[seq(1..5),1 ]                #此时 integers 为列表，结果为 [1, 2, 3, 4, 5, 1]</span><br><span class="line">integers:=convert(integers,list)        #此时 integers 为集合，结果为 &#123;1, 2, 3, 4, 5&#125; 因为集合无顺序且删去重复的元素</span><br></pre></td></tr></table></figure></p>
<p><strong>获取等式的左边/右边</strong>：<code>lhs()</code> 和
<code>rhs()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">equn := x + y = a - b</span><br><span class="line">lhs(equn)                   #获取等式左边，结果为 x + y</span><br><span class="line">rhs(equn)                   #获取等式左边，结果为 a - b</span><br></pre></td></tr></table></figure></p>
<p><strong>函数映射</strong>： <code>map()</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将某个函数（自定义的或系统自带的）映射到某个对象（例如矩阵）的全部元素中去</span><br><span class="line">test1 := &lt;&lt;1 | 2 | 3&gt;, &lt;4 | 5 | 6&gt;, &lt;7 | 8 | 9&gt;&gt;</span><br><span class="line">f := x -&gt; x^2：</span><br><span class="line">test2:=map(f, test1)</span><br></pre></td></tr></table></figure>
结果为： <span class="math display">\[
test1=\begin{bmatrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp;
8 &amp; 9 \end{bmatrix},test2=\begin{bmatrix}1 &amp; 4 &amp; 9 \\\\16
&amp; 25 &amp; 36 \\\\49 &amp; 64 &amp; 81 \end{bmatrix}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test := &lt;&lt;1 | 2 | 3&gt;, &lt;4 | 5 | 6&gt;, &lt;7 | 8 | 9&gt;&gt;     #创建矩阵</span><br><span class="line">int(test, x = 0 .. 2)                               #报错，不可以直接对矩阵进行积分</span><br><span class="line">map(int, test, x = 0 .. 2)                          #将 int() 映射到矩阵中的每个元素，进行积分</span><br></pre></td></tr></table></figure>
<p>结果为： <span class="math display">\[
test=\begin{bmatrix}2 &amp; 4 &amp; 6 \\\\8 &amp; 10 &amp; 12 \\\\14
&amp; 16 &amp; 18 \end{bmatrix}
\]</span></p>
<h2 id="参考书目">参考书目</h2>
<ul>
<li><a
href="https://www.maplesoft.com.cn/support/documentation/PDF/maple2020/Maple2020%E4%B8%AD%E6%96%87%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">《Maple2020中文用户手册》</a></li>
<li><a
href="https://www.maplesoft.com.cn/support/documentation/">Maple文档中心</a></li>
<li><a
href="https://pdc.capub.cn/search.html#/detail?id=yrcnjprstu53gy5l2gvknezqtg5lyoocv7kzwrpwvcxul7qhho7q&amp;from=1&amp;type=marc">《Maple理论力学》
李银山</a></li>
</ul>
]]></content>
      <tags>
        <tag>Maple</tag>
      </tags>
  </entry>
  <entry>
    <title>Timoshenko梁理论与有限元-参考书单及文献</title>
    <url>/2022/04/23/%E6%A2%81%E7%90%86%E8%AE%BA%E4%B8%8E%E6%9C%89%E9%99%90%E5%85%83-%E5%8F%82%E8%80%83%E4%B9%A6%E5%8D%95%E5%8F%8A%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<h2 id="参考文献">参考文献</h2>
<ul>
<li><a
href="https://www.tandfonline.com/doi/abs/10.1080/14786442108636264">Timoshenko本人的论文：</a>
Timoshenko S P. LXVI. On the correction for shear of the differential
equation for transverse vibrations of prismatic bars[J]. The London,
Edinburgh, and Dublin Philosophical Magazine and Journal of Science,
1921, 41(245): 744-746.</li>
<li><a
href="https://asmedigitalcollection.asme.org/mechanicaldesign/article/102/4/793/431834/A-Finite-Rotating-Shaft-Element-Using-Timoshenko">Timoshenko梁的有限元模型-必引论文：</a>
Nelson, H. D. A Finite Rotating Shaft Element Using Timoshenko Beam
Theory[J]. Journal of Mechanical Design, 1980, 102(4): 793-803.</li>
</ul>
<h2 id="参考书目">参考书目</h2>
<ul>
<li><a
href="https://pdc.capub.cn/search.html#/detail?id=rxwi4bijhc2l2grniccyqg3m2wl4catiddfrywhwwstnyzzsqohdce3hws4qrli7wnjko63dk53cu&amp;from=1&amp;type=cip">《材料力学》刘鸿文，梁的基础知识：</a>
刘鸿文. 材料力学[M]. 北京: 高等教育出版社, 2017.</li>
<li><a
href="https://books.google.nl/books?hl=zh-CN&amp;lr=&amp;id=V_UqEAAAQBAJ&amp;oi=fnd&amp;pg=PP12&amp;dq=Finite+Element+Analysis+Method,+Verification+and+Validation&amp;ots=Gpuk8J0Po8&amp;sig=3_tVof3D-jbk1w_f__rNXqe9xI8#v=onepage&amp;q=Finite%20Element%20Analysis%20Method%2C%20Verification%20and%20Validation&amp;f=false">《Finite
Element Analysis》 第1章为有限元原理；第7章为梁模型：</a> Szabó B,
Babuška I. Finite Element Analysis: Method, Verification and
Validation[M]. Hoboken, USA: John Wiley &amp; Sons, Inc. 2021.</li>
<li><a
href="https://pdc.capub.cn/search.html#/detail?id=rr5ylx3wuwniyy5l2gvknezqteq75purtjaa3lg7ejbplby6by4q&amp;from=1&amp;type=marc">《航空发动机转子动力学》廖明夫，第14章第2节为有限元法推导Timoshenko梁模型过程：</a>
廖明夫. 航空发动机转子动力学[M]. 西安：西北工业大学出版社, 2015.</li>
<li><a
href="https://pdc.capub.cn/search.html#/detail?id=te3qsklcdh7mpuxtasm3pfdgg5to2gqavwz25cggzqld4ff36lkq&amp;from=1&amp;type=marc">《转子系统动力学基础与数值仿真》马辉,
第9章第2节为Timoshenko梁有限元模型：</a> 马辉, 韩清凯, 太兴宇, 闻邦椿.
转子系统动力学基础与数值仿真[M]. 武汉：武汉理工大学出版社.</li>
</ul>
<p><strong>备注：</strong>
注意区分各个文献中截面惯性矩、转动惯量、单位长度转动惯量；密度、线密度；面积、有效抗剪面积之间的区别。这些常系数会影响最终质量、刚度等矩阵前的系数。马辉与廖明夫的书中的有限元刚度、质量等矩阵是相等的，通过常系数之间的关系可以推导得到。</p>
]]></content>
      <tags>
        <tag>有限元</tag>
        <tag>mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>数学概念——同伦</title>
    <url>/2022/07/29/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5-%E5%90%8C%E4%BC%A6/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<p><strong>同伦</strong>：在数学和拓扑学上描述了两个对象间的“连续变化”。</p>
<p>两个定义在拓扑空间之间的连续函数，如果其中一个能“连续地形变”为另一个，则这两个函数称为同伦的。这样的<strong>形变</strong>称为两个函数之间的同伦。</p>
<p><img src="/image/homotopy/HomotopySmall.gif" width = "25%"  /></p>
<h2 id="定义">定义</h2>
<p>给定两个拓扑空间 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span>。考虑两个连续函数 <span
class="math inline">\(f, g: X\rightarrow
Y\)</span>，若存在一个定义在空间 <span class="math inline">\(X\)</span>
与单位区间 <span class="math inline">\([0,1]\)</span>
的积空间上的连续映射 <span class="math inline">\(H: X \times [0,1]
\rightarrow Y\)</span> 使得：</p>
<ul>
<li><span class="math inline">\(\forall x \in X,
H(x,0)=f(x)\)</span></li>
<li><span class="math inline">\(\forall x \in X,
H(x,1)=g(x)\)</span></li>
</ul>
<p>则称 <span class="math inline">\(H\)</span> 是 <span
class="math inline">\(f, g\)</span> 之间的一个同伦。</p>
<p>如果我们将 <span class="math inline">\(H\)</span>
的第二个参数当作时间，这样 <span class="math inline">\(H\)</span>
相当于描述了一个从 <span class="math inline">\(f\)</span> 到 <span
class="math inline">\(g\)</span> 的连续形变： 0 时刻得到函数 <span
class="math inline">\(f\)</span>，1时刻得到函数 <span
class="math inline">\(g\)</span>， 反之亦然。</p>
<p><img src="/image/homotopy/Mug_and_Torus_morph.gif" width = "35%"  /></p>
<h2 id="reference">Reference</h2>
<ul>
<li><a
href="https://zh.wikipedia.org/wiki/%E5%90%8C%E5%80%AB">维基百科-同伦</a></li>
</ul>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>转动惯量/截面惯性矩/极惯性矩</title>
    <url>/2022/04/23/%E8%BD%AC%E5%8A%A8%E6%83%AF%E9%87%8F-%E6%88%AA%E9%9D%A2%E6%83%AF%E6%80%A7%E7%9F%A9-%E6%9E%81%E6%83%AF%E6%80%A7%E7%9F%A9/</url>
    <content><![CDATA[<h2 id="转动惯量">转动惯量</h2>
<h3 id="概念">概念</h3>
<p>在经典力学中，<strong>转动惯量</strong>又称<strong>惯性矩</strong>（英语：moment
of inertia, mass moment of inertia, second moment of mass,
最准确的表达应该是 rotational inertia），通常以 <span
class="math inline">\(I\)</span> 表示，国际单位制为 <span
class="math inline">\(kg \cdot m^2\)</span>。</p>
<p>转动惯量是一个物体对于其旋转运动的惯性大小的量度。一个刚体对于某转轴的转动惯量决定对于这物体绕着这转轴进行某种角加速度运动所需要施加的力矩。</p>
<h3 id="定义">定义</h3>
<p>对于刚体，其转动惯量由积分表示： <span class="math display">\[
I=\int \rho r^2 dV
\]</span></p>
<p>其中 <span class="math inline">\(\rho\)</span> 是密度， <span
class="math inline">\(dV\)</span> 是微元的体积。</p>
<h3 id="转动动能">转动动能</h3>
<p>在直线运动中，物体的动能是：<span class="math inline">\(K=\frac{1}{2}
mv^2\)</span> ，在转动中， <span class="math inline">\(v=\omega
r\)</span> 且 <span class="math inline">\(m=\int \rho dV\)</span>，则：
<span class="math display">\[
K= \frac{1}{2} \int \rho \omega r^2 dV =  \frac{1}{2} \left(\int
\rho  r^2 dV \right)\omega^2
\]</span></p>
<p><span class="math display">\[
K=\frac{1}{2} I \omega^2
\]</span></p>
<h3 id="转动惯量列表">转动惯量列表</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">描述</th>
<th style="text-align: center;">示意图</th>
<th style="text-align: center;">转动惯量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">质点</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/PointInertia.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I=mr^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">细棒-绕中心</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_rod_center.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_{center}=\frac{1}{12}mL^2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">细棒-绕端点</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_rod_end.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_{end}=\frac{1}{3}mL^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">细圆环</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_hoop.svg" width = "30%"  /></td>
<td style="text-align: center;">$I_z=mr^2 $</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{2}mr^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">圆盘</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_disc.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{1}{2}mr^2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{4}mr^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">环形圆盘</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_annulus.svg" width = "30%"  /></td>
<td style="text-align: center;">$I_z=m(r_1<sup>2+r_2</sup>2) $</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{4}m(r_1^2+r_2^2)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">圆柱壳</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_thin_cylinder.png" width = "30%"  /></td>
<td style="text-align: center;"><span class="math inline">\(I\approx
mr^2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">圆柱</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_solid_cylinder.svg" width = "30%"  /></td>
<td style="text-align: center;">$I_z=mr^2 $</td>
</tr>
<tr class="even">
<td style="text-align: center;">圆柱</td>
<td style="text-align: center;">center</td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{12}m(3r^2+h^2)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">圆柱</td>
<td style="text-align: center;">end</td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{12}m(3r^2+4h^2)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">空心圆柱</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_thick_cylinder_h.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{1}{2}m(r_1^2+r_2^2)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">空心圆柱</td>
<td style="text-align: center;">center</td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{12}m(3(r_1^2+r_2^2)+h^2)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">空心圆柱</td>
<td style="text-align: center;">end</td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{1}{12}m(3(r_1^2+r_2^2)+4h^2)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">长方体</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_inertia_solid_rectangular_prism.png" width = "30%"  /></td>
<td style="text-align: center;">$I_h=m(w<sup>2+d</sup>2) $</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$I_w=m(d<sup>2+h</sup>2) $</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_d=\frac{1}{12}m(w^2+h^2)\)</span></td>
</tr>
</tbody>
</table>
<h2 id="截面惯性矩">截面惯性矩</h2>
<h3 id="概念-1">概念</h3>
<p><strong>截面惯性矩</strong>又称<strong>面积二次轴矩</strong>=横截面的惯性矩=面积惯性矩
(英语：second moment of aera, second aera mement, quadratic moment of
aera, aera moment of inertia)
通常是对受弯曲作用物体的横截面而言，是反映截面的形状与尺寸对弯曲变形影响的物理量。弯曲作用下的变形或挠度不仅取决于荷载的大小，还与横截面的几何特性有关。如工字梁的抗弯性能就比相同截面尺寸的矩形梁好。它和反映截面抗扭转作用性能的<strong>面积极惯性矩</strong>是相似的。</p>
<h3 id="定义-1">定义</h3>
<p>截面的面积为 <span class="math inline">\(A\)</span>，则： <span
class="math display">\[
I_x = \int_A y^2 dA=\int \int y^2 dx dy
\]</span></p>
<p><span class="math display">\[
I_y = \int_A x^2 dA=\int \int x^2 dx dy
\]</span> 分别表示截面对坐标轴<span
class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>的惯性矩，第一式中的 <span
class="math inline">\(y\)</span> 和第二式中的 <span
class="math inline">\(x\)</span> 分别表示面积微元 <span
class="math inline">\(dA\)</span> 到 <span
class="math inline">\(x\)</span> 和到 <span
class="math inline">\(y\)</span> 轴的垂直距离。</p>
<h3 id="截面惯性矩列表含极惯性矩">截面惯性矩列表（含极惯性矩）</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">描述</th>
<th style="text-align: center;">示意图</th>
<th style="text-align: center;">截面惯性矩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">圆</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_area_of_a_circle.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{\pi}{4}r^4\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{\pi}{4}r^4\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">圆环</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_area_of_an_annulus.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=I_y=\frac{\pi}{4}(r_2^4-r_1^4)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{\pi}{2}(r_2^4-r_1^4)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">长方形-中心</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_area_of_a_rectangle_through_the_centroid.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=\frac{bh^3}{12}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_y=\frac{b^3h}{12}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{b^3h+bh^3}{12}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">长方形-端点</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_area_of_a_rectangle_through_the_base.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=\frac{bh^3}{3}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_y=\frac{b^3h}{3}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_z=\frac{b^3h+bh^3}{3}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">长方形-空心</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_area_of_a_hollow_rectangle.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=\frac{bh^3-b_1h_1^3}{12}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_y=\frac{b^3h-b_1^3h_1}{12}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">三角形-形心</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_aera_of_a_triangle_through_centroide.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=\frac{bh^3}{36}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_y=\frac{b^3h-b^2ha+bha^2}{36}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">三角形-端点</td>
<td
style="text-align: center;"><img src="/image/MomentOfInertia/Moment_of_aera_of_a_traingle_through_the_base.svg" width = "30%"  /></td>
<td style="text-align: center;"><span
class="math inline">\(I_x=\frac{bh^3}{12}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(I_y=\frac{b^3h+b^2ha+bha^2}{12}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="极惯性矩">极惯性矩</h2>
<h3 id="概念-2">概念</h3>
<p><strong>极惯性矩</strong>又称<strong>截面二次极矩</strong>
(英语：second polar moment of aera, polar moment of inertia)
通常是对受扭转作用物体的横截面而言，是反应截面形状与尺寸对扭转变形影响的物理量。通常用
<span class="math inline">\(I_z\)</span> 或 <span
class="math inline">\(I_p\)</span> 表示。</p>
<h3 id="定义-2">定义</h3>
<p>截面的面积为 <span class="math inline">\(A\)</span>，且面积微元 <span
class="math inline">\(dA\)</span> 到 <span
class="math inline">\(z\)</span> 轴的距离为 <span
class="math inline">\(\rho\)</span> 则： <span class="math display">\[
I_z = \int_A \rho^2 dA=\int \int x^2+y^2 dx dy
\]</span></p>
<p>截面惯性矩与极惯性矩的关系为：</p>
<p><span class="math display">\[
I_z = \int_A \rho^2 dA=\int \int y^2+x^2 dx dy = I_x + I_y
\]</span></p>
<h2 id="三者的区别">三者的区别</h2>
<ul>
<li><strong>转动惯量</strong>：转动惯量越大，惯性越大，物体旋转越难改变（需要的力矩越大）与质量分布有关；</li>
<li><strong>截面惯性矩</strong>：截面惯性矩越大，物体越难弯曲，抗弯截面模量也越大。与质量分布无关。</li>
<li><strong>极惯性矩</strong>：极惯性矩越大，物体越难扭转。与质量分布无关。与截面惯性矩的关系为：
<span class="math inline">\(I_z=I_x+I_y\)</span>。</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a
href="https://zh.wikipedia.org/wiki/%E6%88%AA%E9%9D%A2%E4%BA%8C%E6%AC%A1%E8%BD%B4%E7%9F%A9">维基百科-截面二次轴距</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F">维基百科-转动惯量</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/%E6%9E%81%E6%83%AF%E6%80%A7%E7%9F%A9">维基百科-极惯性矩</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Moment_of_inertia">Wikipedia-Moment
of inertia</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Second_moment_of_area">Wikipedia-Second
moment of area</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Second_Polar_Moment_of_Area">Wikipedia-Second
Polar Moment of Area</a></li>
<li><a
href="https://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia-List
of moments of inertia</a></li>
<li><a
href="https://en.wikipedia.org/wiki/List_of_second_moments_of_area">Wikipedia-List
of second moments of area</a></li>
<li><a
href="https://www.zhihu.com/question/296107343/answer/1625307850">材料力学里求惯性矩有什么用？怎么理解惯性矩</a></li>
</ul>
]]></content>
      <tags>
        <tag>mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵求导</title>
    <url>/2022/04/23/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="公约">公约</h2>
<p>若<span class="math inline">\(\bar{y}=\Psi(\bar{x})\)</span>，其中
<span class="math inline">\(\bar{y},\bar{x}\)</span> 分别是 <span
class="math inline">\(m\times 1,n\times 1\)</span>
向量，则有Jacobian矩阵： <span class="math display">\[
\frac{\partial\bar{y}}{\partial\bar{x}} = \begin{bmatrix} \frac{\partial
y_1}{\partial x_1} &amp; \frac{\partial y_1}{\partial x_2} &amp; \cdots
&amp; \frac{\partial y_1}{\partial x_n} \\\\ \frac{\partial
y_2}{\partial x_1} &amp; \frac{\partial y_2}{\partial x_2} &amp; \cdots
&amp; \frac{\partial y_2}{\partial x_n} \\\\ \vdots &amp; \vdots &amp;
\ddots &amp; \vdots \\\\ \frac{\partial y_n}{\partial x_1} &amp;
\frac{\partial y_n}{\partial x_2} &amp; \cdots &amp;\frac{\partial
y_n}{\partial x_n} \end{bmatrix}
\]</span></p>
<p>按照该公约：如果 <span class="math inline">\(x\)</span>
是标量，则Jacobian矩阵是 <span class="math inline">\(m \times 1\)</span>
列向量；如果 <span class="math inline">\(y\)</span>
是标量，则Jacobian矩阵是 $ 1 n$ 行向量。</p>
<h2 id="定理-1">定理 1</h2>
<p>若 <span class="math inline">\(\bar{y}=\mathbf{A}
\bar{x}\)</span>，则: <span class="math display">\[
\frac{\partial\bar{y}}{\partial\bar{x}}=\mathbf{A}
\]</span></p>
<h2 id="定理-2">定理 2</h2>
<p>若标量 <span class="math inline">\(\alpha\)</span> 满足 <span
class="math inline">\(\alpha =\bar{y}^T\mathbf{A} \bar{x}\)</span>，则:
<span class="math display">\[
\frac{\partial \alpha}{\partial\bar{x}}=\bar{y}^T\mathbf{A},\;
\frac{\partial \alpha}{\partial\bar{y}}=\bar{x}^T\mathbf{A}^T
\]</span></p>
<h2 id="定理-3">定理 3</h2>
<p>若标量 <span class="math inline">\(\alpha\)</span> 满足 <span
class="math inline">\(\alpha =\bar{x}^T\mathbf{A} \bar{x}\)</span>，则:
<span class="math display">\[
\frac{\partial \alpha}{\partial\bar{x}}=\bar{x}^T \left( \mathbf{A}^T +
\mathbf{A} \right)
\]</span></p>
<hr />
<ul>
<li>上式证明过程参考：<a
href="https://atmos.washington.edu/~dennis/MatrixCalculus.pdf">《Matrix
Differentiation》 Randal J. Barnes</a></li>
<li>矩阵相关变换参考：<a
href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">《Matrix
Cookbook》 Kaare Brandt Petersen</a></li>
</ul>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometrical Nonlinear and Material Nonlinear</title>
    <url>/2022/08/02/geometricalNonlinearAndMaterialNonlinear/</url>
    <content><![CDATA[<h2 id="geometrical-nonlinear">Geometrical Nonlinear</h2>
<p>In the geometrical nonlinear case, the relationship internal
force-displacements is nonlinear.</p>
<h2 id="material-nonlinaer">Material Nonlinaer</h2>
<p>In the material nonlinear case, the relationship of the stress-strain
is nonlinear.</p>
<p>Of course these cases may be independent of each other or
combined.</p>
<ul>
<li><strong>From Czeslaw Kazimierz Szymczak</strong>:
https://www.researchgate.net/post/What_is_Geomertical_Nonlinearity/2</li>
</ul>
]]></content>
      <tags>
        <tag>mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性方程的延拓法</title>
    <url>/2022/08/01/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E5%BB%B6%E6%8B%93%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<ul>
<li><strong>前置概念</strong>：<a
href="/2022/07/29/数学概念-同伦/">同伦</a></li>
<li><strong>作用对象</strong>：非线性方程组</li>
<li><strong>目的</strong>：扩大非线性方程组的收敛域</li>
</ul>
<h2 id="延拓法的基本思想">延拓法的基本思想</h2>
<ol type="1">
<li>已知一个待求解的非线性方程组 <span
class="math inline">\(F(x)=0\)</span></li>
<li>在方程组中引入一个参数 <span
class="math inline">\(\lambda\)</span>，构造 <span
class="math inline">\(F(x)\)</span> 的<strong>同伦映射</strong> <span
class="math inline">\(H(x,\lambda), \lambda \in [0,1]\)</span>, 使得
<span class="math inline">\(H(x,0)=0, H(x,1)=F(x)\)</span><br />
</li>
<li>已知 <span class="math inline">\(H(x,0)=0\)</span> 的解是 <span
class="math inline">\(x=x_0\)</span> (可以是零向量 <span
class="math inline">\(\bar{0}\)</span> )</li>
<li>数值迭代，求解满足 <span class="math inline">\(H(x,1)=0\)</span>
的解 <span class="math inline">\(x^*\)</span>
<ul>
<li>构造序列 <span class="math inline">\(\\{ \lambda_i \\} =
\\{0,...,\lambda_i,...1\\}, i = 0,1,2,...,N\)</span></li>
<li>以 <span class="math inline">\(x_0\)</span> 为初值，求解 <span
class="math inline">\(H(x,\lambda_1)=0\)</span>
（例如，Netwon迭代），解为 <span class="math inline">\(x_1\)</span></li>
<li>以 <span class="math inline">\(x_1\)</span> 为初值，求解 <span
class="math inline">\(H(x,\lambda_2)=0\)</span>，解为 <span
class="math inline">\(x_2\)</span></li>
<li>以 <span class="math inline">\(x_i\)</span> 为初值，求解 <span
class="math inline">\(H(x,\lambda_{i+1})=0\)</span>，解为 <span
class="math inline">\(x_{i+1}\)</span></li>
<li>最终求得 <span class="math inline">\(H(x,1)=0\)</span> 的解 <span
class="math inline">\(x_N\)</span>, 即 <span
class="math inline">\(F(x)=0\)</span>的解 <span
class="math inline">\(x^*\)</span></li>
</ul></li>
<li>该方法的结果相当于扩大了传统非线性方程组迭代求解方法的收敛域</li>
</ol>
<p><strong>Mark 1</strong>：
Newton迭代时，可只迭代一步，因为最终目标是求 <span
class="math inline">\(\boldsymbol{x}^*\)</span> <strong>Mark
2</strong>：<span class="math inline">\(N\)</span> 足够大</p>
<h2 id="延拓法的数学表述">延拓法的数学表述</h2>
<p>传统的求解非线性方程组求解方法是局部收敛的，只有初值 <span
class="math inline">\(x_0\)</span>
足够接近真值，迭代方法收敛。然而，延拓法作为可以扩大收敛域的有效方法，可以从任意的
<span class="math inline">\(x_0\)</span> 出发，通过延拓求解得到方程的解
<span class="math inline">\(x^*\)</span>。</p>
<p>引入参数 <span
class="math inline">\(\lambda\)</span>，构造一簇同伦映射 <span
class="math inline">\(\boldsymbol{H}:D\times[0,1] \subset
\mathbf{R}^{n+1}\rightarrow \mathbf{R}^n\)</span> 代替单映射 <span
class="math inline">\(\boldsymbol{F}(\boldsymbol{x})\)</span>，令 <span
class="math inline">\(\boldsymbol{H}\)</span> 满足条件：</p>
<p><span class="math display">\[
\boldsymbol{H}(\boldsymbol{x}_0,0)=\boldsymbol{0}
\]</span></p>
<p><span class="math display">\[
\boldsymbol{H}(\boldsymbol{x},1)=\boldsymbol{F}(\boldsymbol{x})
\]</span></p>
<p>它表明当 <span class="math inline">\(\lambda=0\)</span> 时，<span
class="math inline">\(\boldsymbol{H}(\boldsymbol{x},0)=\boldsymbol{0}\)</span>
的解 <span class="math inline">\(\boldsymbol{x}_0\)</span> 已知；当
<span class="math inline">\(\lambda=1\)</span> 时，<span
class="math inline">\(\boldsymbol{H}(\boldsymbol{x},1)=\boldsymbol{F}(\boldsymbol{x})=0\)</span>
的解 <span class="math inline">\(\boldsymbol{x}^*\)</span>
为非线性方程组的解。</p>
<p>现考虑同伦方程：</p>
<p><span class="math display">\[
\boldsymbol{H}(\boldsymbol{x},\lambda)=\boldsymbol{0} \\quad
\lambda \in [0,1],\boldsymbol{x}\in D \subset\mathbf{R}^n
\]</span></p>
<p>如果对每个 <span class="math inline">\(\lambda
\in[0,1]\)</span>，上述方程有解 <span
class="math inline">\(\boldsymbol{x}=\boldsymbol{x}(\lambda),
\boldsymbol{x}:[0,1]\rightarrow D\)</span> 且连续，则 <span
class="math inline">\(\boldsymbol{x}=\boldsymbol{x}(\lambda)\)</span>
是关于参数 <span class="math inline">\(\lambda\in[0,1]\)</span> 在 <span
class="math inline">\(\mathbf{R}^{n+1}\)</span>
中的一条曲线。该曲线的一端为已知点 <span
class="math inline">\((\boldsymbol{x}_0,0)\)</span>，另一端是点 <span
class="math inline">\((\boldsymbol{x}^*,1)\)</span>，<span
class="math inline">\(\boldsymbol{x}^*\)</span>
即为非线性方程组的解，这就是<strong>延拓法</strong>，也被称作<strong>同伦法</strong>。</p>
<p>满足条件的同伦可以有各种不同的取法，常用的有两种。</p>
<p>牛顿同伦： <span class="math display">\[
\boldsymbol{H}(\boldsymbol{x},\lambda)
=\boldsymbol{F}(\boldsymbol{x})
+(\lambda-1)\boldsymbol{F}(\boldsymbol{x}_0)
\]</span></p>
<p>凸同伦： <span class="math display">\[
\boldsymbol{H}(\boldsymbol{x},\lambda)
= t \boldsymbol{F}(\boldsymbol{x})
+(1-\lambda)\boldsymbol{A}(\boldsymbol{x} - \boldsymbol{x}_0)
\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{A}\in\mathbf{R}^{n\times
n}\)</span> 是非奇的</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculate Contact Stiffness for dynamic rolling bearing model</title>
    <url>/2023/11/25/contact-stiffness-for-bearing/</url>
    <content><![CDATA[<h2 id="circular-contact">Circular Contact</h2>
<p><img src="/image/contactStiffness/circleContact.png" width = "40%"  /></p>
<p><img src="/image/contactStiffness/contact_R.png" width = "50%"  /></p>
<h3 id="symbols">Symbols</h3>
<ul>
<li><span class="math inline">\(\delta\)</span>: distance between two
spheres</li>
<li><span class="math inline">\(E_i,\nu_i\)</span>: the elastic modulus
and Poisson's ratio for the i-th sphere</li>
<li><span class="math inline">\(R_i\)</span>: the radius of the i-th
sphere</li>
<li><span class="math inline">\(F\)</span>: force on spheres</li>
<li><span class="math inline">\(b\)</span>: the half width of
contact</li>
<li><span class="math inline">\(E^*\)</span>: the combined modulus of
two spheres</li>
<li><span class="math inline">\(R^*\)</span>: reciprocal of relative
curvature for two spheres</li>
</ul>
<h3 id="equations">Equations</h3>
<p><span class="math display">\[
{\delta}^3=
\left(\frac{3}{4E^*}\right)^2
\frac{F^2}{R^*}
\]</span></p>
<p><span class="math display">\[
F = \left( \frac{4E^*\sqrt{R^*}}{3} \right)
\delta^\frac{3}{2}=k_{\mathrm{Hertz}} \; \delta^\frac{3}{2}
\]</span></p>
<p><span class="math display">\[
\frac{1}{E^*} = \frac{(1-\nu_1^2)}{E_1} + \frac{(1-\nu_2^2)}{E_2}
\]</span></p>
<p><span class="math display">\[
\frac{1}{R^*}
= \frac{1}{R_1} + \frac{1}{R_2}
\]</span></p>
<h3 id="case">Case</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line">% choose the bearing to calculte contact stiffness</span><br><span class="line">bearingType = 6212;</span><br><span class="line">switch bearingType</span><br><span class="line">    case 6204</span><br><span class="line">        % SKF 6204 bearing</span><br><span class="line">        % Physics parameters</span><br><span class="line">        E1 = 210e9; % elastic modulus (Pa)</span><br><span class="line">        nu1 = 0.3; % poison&#x27;s ratio</span><br><span class="line">        E2 = E1;</span><br><span class="line">        nu2 = nu1;</span><br><span class="line">        % Geometrics parameters</span><br><span class="line">        R1 = 3.97e-3; % radius of sphere 1 (m)</span><br><span class="line">        R2 = -20.7e-3;</span><br><span class="line">        disRange = 1e-3; % clearance + deformation</span><br><span class="line">    case 6212</span><br><span class="line">        % SKF 6212 bearing</span><br><span class="line">        % Physics parameters</span><br><span class="line">        E1 = 210e9; % elastic modulus (Pa)</span><br><span class="line">        nu1 = 0.3; % poison&#x27;s ratio</span><br><span class="line">        E2 = E1;</span><br><span class="line">        nu2 = nu1;</span><br><span class="line">        % Geometrics parameters</span><br><span class="line">        R1 = 7.94e-3; % radius of sphere 1 (m)</span><br><span class="line">        R2 = -50.43e-3;</span><br><span class="line">        disRange = 1.3e-3; % clearance + deformation</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% calculated parameters</span><br><span class="line">Ec = ((1-nu1^2)/E1 + (1-nu2^2)/E2)^-1; % combined modulus</span><br><span class="line">Rc = (1/R1 + 1/R2)^-1;</span><br><span class="line">kHertz = 4/3 * (Ec*Rc^(1/2));</span><br><span class="line"></span><br><span class="line">% Force and displacement</span><br><span class="line">num = 1000;</span><br><span class="line">delta = linspace(0,disRange,num);</span><br><span class="line">FCircle = kHertz * delta.^(3/2);</span><br><span class="line"></span><br><span class="line">% plot delta-F</span><br><span class="line">plot(delta,FCircle)</span><br><span class="line">xlabel(&#x27;$\delta$ (m)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">ylabel(&#x27;$F$ (N)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">title(&#x27;Circle Contact&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<p><img src="/image/contactStiffness/6212-ball-analytics.svg" width = "70%"  /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fprintf(&#x27;kHertz = %d&#x27;, kHertz);</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<p>kHertz = 1.493475e+10</p>
<h2 id="line-contact">Line Contact</h2>
<p><img src="/image/contactStiffness/lineContact.png" width = "50%"  /></p>
<h3 id="symbols-1">Symbols</h3>
<ul>
<li><span class="math inline">\(\delta\)</span>: distance between two
cylinders</li>
<li><span class="math inline">\(E_i,\nu_i\)</span>: the elastic modulus
and Poisson's ratio for the i-th cylinder</li>
<li><span class="math inline">\(R_i\)</span>: the radius of the i-th
cylinder</li>
<li><span class="math inline">\(F\)</span>: force on cylinders</li>
<li><span class="math inline">\(b\)</span>: the half width of
contact</li>
<li><span class="math inline">\(E^*\)</span>: the combined modulus of
two cylinders</li>
<li><span class="math inline">\(R^*\)</span>: reciprocal of relative
curvature for two cylinders</li>
<li><span class="math inline">\(L\)</span>: the length of the contact
area</li>
</ul>
<h3 id="equations-radzimovsky-model">Equations (Radzimovsky Model)</h3>
<p><span class="math display">\[
\delta = \frac{F}{\pi LE^*}  \left( \ln{\frac{4R_1}{b}}  +
\ln{\frac{4R_2}{b}}  + \frac{2}{3}\right)
\]</span></p>
<p><span class="math display">\[
b = 2 \sqrt{\frac{FR^*}{\pi L E^*}}
\]</span></p>
<p><span class="math display">\[
\frac{1}{E^*}  = \frac{(1-\nu_1^2)}{E_1} + \frac{(1-\nu_2^2)}{E_2}
\]</span></p>
<p><span class="math display">\[
\frac{1}{R^*} = \frac{1}{R_1} + \frac{1}{R_2}
\]</span></p>
<h3 id="equations-johnsons-model">Equations (Johnson's Model)</h3>
<p>There is another model called Johnson's model.</p>
<p><span class="math display">\[
\delta(F) = \delta_1(F) + \delta_2(F)
\]</span></p>
<p><span class="math display">\[
\delta_i(F) = \frac{F(1-\nu_i^2)}{\pi L E_i} \left( 2 \ln{\frac{4R_1}{b}
- 1} \right)
\]</span></p>
<p><span class="math display">\[
b = 2 \sqrt{\frac{FR^*}{\pi L E^*}}
\]</span></p>
<p>Consider <span class="math inline">\(E_1 = E_2 = E,\; R_1 = R_2
=R\)</span>, the above equations could be simplified:</p>
<p><span class="math display">\[
\delta = \delta_1 + \delta_2 = \frac{2F(1-\nu^2)}{\pi LE}  \left(
\ln{\frac{4R_1}{b}}  + \ln{\frac{4R_2}{b}}  - 1\right)
\]</span></p>
<p>As Pereira said "Only the Johson and the Radzimovsky models are
suitable to describe the contact involving colliding cylinders in most
of practical applications."</p>
<h3 id="case-1">Case</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% the physics and geometrics parameters are same as circle contact</span><br><span class="line">L = 4*R1; % the length of contact</span><br><span class="line"></span><br><span class="line">b = @(F) 2*((F*Rc)/(pi*L*Ec)).^(1/2); % half width of contact</span><br><span class="line">% nonlinear funciton respect to F (Radzimovsky model)</span><br><span class="line">fdeltaRadzi = @(F) F./(pi*L*Ec) .*(log(4*abs(R1)./b(F))+log(4*abs(R2)./b(F)+2/3));</span><br><span class="line"></span><br><span class="line">% nonlinear funciton respect to F (Johnson model)</span><br><span class="line">fdeltaJohnsoni = @(F,nu,E,R) F.*(1-nu^2)/(pi*L*E) .* (2*log(4*abs(R)./b(F)) - 1);</span><br><span class="line">fdeltaJohnson = @(F,nu1,E1,R1,nu2,E2,R2) fdeltaJohnsoni(F,nu1,E1,R1) + fdeltaJohnsoni(F,nu2,E2,R2);</span><br><span class="line"></span><br><span class="line">% calculte relation</span><br><span class="line">F = linspace(0.1,1e6,num);</span><br><span class="line">deltaRadzi = fdeltaRadzi(F);</span><br><span class="line">deltaJohnson = fdeltaJohnson(F,nu1,E1,R1,nu2,E2,R2);</span><br><span class="line"></span><br><span class="line">% plot</span><br><span class="line">plot(deltaRadzi, F, &quot;LineWidth&quot;,2); hold on</span><br><span class="line">plot(deltaJohnson, F, &quot;LineWidth&quot;,2)</span><br><span class="line">xlabel(&#x27;$\delta$ (m)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">ylabel(&#x27;$F$ (N)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">title(&#x27;Line Contact - Analytical Model&#x27;)</span><br><span class="line">legend(&#x27;Radzimovsky Model&#x27;,&#x27;Johnson Model&#x27;,&quot;Location&quot;,&quot;best&quot;)</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<p><img src="/image/contactStiffness/line-contact-analytics.svg" width = "70%"  /></p>
<h3
id="polynomial-interpolation-to-calculate-contact-stiffness">Polynomial
Interpolation to Calculate Contact Stiffness</h3>
<p>In general, we used to use a approximate polynomial to fit the
nonlinear equation about the line contact. The polynomial looks
like:</p>
<p><span class="math display">\[
F = k_{Hertz} \; \delta^n
\]</span></p>
<p>where <span class="math inline">\(n=10/9\)</span> for line
contact.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% initial value for fit</span><br><span class="line">n = 10/9;</span><br><span class="line">k0 = 1e10; </span><br><span class="line">n0 = 1; </span><br><span class="line">% fitfun1(): k is unknown</span><br><span class="line">fitfun1 = @(k,delta) k.*delta.^n; % n = 9/10</span><br><span class="line">% fitfun2(): k and n are unknown</span><br><span class="line">fitfun2 = @(para,delta) para(1).*delta.^para(2); % para is established for nlinfit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% fit for Radzimovasky model</span><br><span class="line">% fitfun1</span><br><span class="line">[kRadzi1, ~,~,~,MSERadzi1,~] = nlinfit(deltaRadzi, F, fitfun1, k0); </span><br><span class="line">% fitfun2</span><br><span class="line">[fitParaResult, ~,~,~,MSERadzi2,~] = nlinfit(deltaRadzi, F, fitfun2, [k0, n0]); </span><br><span class="line">kRadzi2 = fitParaResult(1);</span><br><span class="line">nRadzi2 = fitParaResult(2); </span><br><span class="line">% plot for Radzimovasky model</span><br><span class="line">plot(deltaRadzi,F,...</span><br><span class="line">     &quot;LineWidth&quot;,2); hold on</span><br><span class="line">plot(deltaRadzi,fitfun1(kRadzi1,deltaRadzi),...</span><br><span class="line">     &#x27;o&#x27;,...</span><br><span class="line">     &#x27;MarkerIndices&#x27;, 1:num/20:num); hold on</span><br><span class="line">plot(deltaRadzi,fitfun2([kRadzi2,nRadzi2],deltaRadzi),...</span><br><span class="line">     &#x27;s&#x27;,...</span><br><span class="line">     &#x27;MarkerIndices&#x27;, 1:num/20:num); hold off</span><br><span class="line">xlabel(&#x27;$\delta$ (m)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">ylabel(&#x27;$F$ (N)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">title(&#x27;Line Contact - Fit Model - Radzimovasky&#x27;)</span><br><span class="line">legend( &#x27;Radzimovasky model&#x27;,...</span><br><span class="line">        &#x27;$F = k_&#123;Hertz&#125; \delta^&#123;10/9&#125;$&#x27;,...</span><br><span class="line">        &#x27;$F = k_&#123;Hertz&#125; \delta^n$&#x27;,...</span><br><span class="line">        &#x27;Interpreter&#x27;,&quot;latex&quot;,...</span><br><span class="line">        &quot;Location&quot;,&quot;best&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/image/contactStiffness/line-contact-radimovasky.svg" width = "70%"  /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% print fit result</span><br><span class="line">fprintf([&#x27;       k unknow  k and n unknow\n&#x27; ...</span><br><span class="line">         &#x27;n      %6.6f  %6.6f\n&#x27;...</span><br><span class="line">         &#x27;KHertz %6.2e  %6.2e\n&#x27;...</span><br><span class="line">         &#x27;MSE    %6.2e  %6.2e&#x27;],...</span><br><span class="line">         n, nRadzi2,...</span><br><span class="line">         kRadzi1, kRadzi2,...</span><br><span class="line">         MSERadzi1, MSERadzi2); </span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>k unknow</th>
<th>k and n unknow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n</td>
<td>1.111111</td>
<td>1.138093</td>
</tr>
<tr class="even">
<td>KHertz</td>
<td>3.39e+09</td>
<td>4.17e+09</td>
</tr>
<tr class="odd">
<td>MSE</td>
<td>2.19e+07</td>
<td>9.76e+05</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% fit for Johnson model</span><br><span class="line">% fitfun1</span><br><span class="line">[kJohnson1, ~,~,~,MSEJohnson1,~] = nlinfit(deltaJohnson, F, fitfun1, k0); </span><br><span class="line">% fitfun2</span><br><span class="line">[fitParaResult, ~,~,~,MSEJohnson2,~] = nlinfit(deltaJohnson, F, fitfun2, [k0, n0]); </span><br><span class="line">kJohnson2 = fitParaResult(1);</span><br><span class="line">nJohnson2 = fitParaResult(2); </span><br><span class="line">% plot for Radzimovasky model</span><br><span class="line">plot(deltaJohnson,F,...</span><br><span class="line">     &quot;LineWidth&quot;,2); hold on</span><br><span class="line">plot(deltaJohnson,fitfun1(kJohnson1,deltaJohnson),...</span><br><span class="line">     &#x27;o&#x27;,...</span><br><span class="line">     &#x27;MarkerIndices&#x27;, 1:num/20:num); hold on</span><br><span class="line">plot(deltaJohnson,fitfun2([kJohnson2,nJohnson2],deltaJohnson),...</span><br><span class="line">     &#x27;s&#x27;,...</span><br><span class="line">     &#x27;MarkerIndices&#x27;, 1:num/20:num); hold off</span><br><span class="line">xlabel(&#x27;$\delta$ (m)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">ylabel(&#x27;$F$ (N)&#x27;,&#x27;Interpreter&#x27;,&quot;latex&quot;)</span><br><span class="line">title(&#x27;Line Contact - Fit Model - Johnson&#x27;)</span><br><span class="line">legend( &#x27;Johnson model&#x27;,...</span><br><span class="line">        &#x27;$F = k_&#123;Hertz&#125; \delta^&#123;10/9&#125;$&#x27;,...</span><br><span class="line">        &#x27;$F = k_&#123;Hertz&#125; \delta^n$&#x27;,...</span><br><span class="line">        &#x27;Interpreter&#x27;,&quot;latex&quot;,...</span><br><span class="line">        &quot;Location&quot;,&quot;best&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/image/contactStiffness/line-contact-johnson.svg" width = "70%"  /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% print fit result</span><br><span class="line">fprintf([&#x27;       k unknow  k and n unknow\n&#x27; ...</span><br><span class="line">         &#x27;n      %6.6f  %6.6f\n&#x27;...</span><br><span class="line">         &#x27;KHertz %6.2e  %6.2e\n&#x27;...</span><br><span class="line">         &#x27;MSE    %6.2e  %6.2e&#x27;],...</span><br><span class="line">         n, nJohnson2,...</span><br><span class="line">         kJohnson1, kJohnson2,...</span><br><span class="line">         MSEJohnson1, MSEJohnson2); </span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>k unknow</th>
<th>k and n unknow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n</td>
<td>1.111111</td>
<td>1.160895</td>
</tr>
<tr class="even">
<td>KHertz</td>
<td>3.94e+09</td>
<td>5.80e+09</td>
</tr>
<tr class="odd">
<td>MSE</td>
<td>7.10e+07</td>
<td>1.72e+06</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<ol type="1">
<li>Hale, Layton C. Appendix C: Contact Mechanics, in "Principles and
techniques for desiging precision machines." MIT PhD Thesis, 1999. pp.
417-426.</li>
<li>K. L. Johnson, “Non-Hertzian normal contact of elastic bodies,” in
Contact Mechanics, Cambridge: Cambridge University Press, 1985, pp.
107–152.</li>
<li>A. C. Fischer-Cripps, "Elastic Contact," In Introduction to Contact
Mechanics. Mechanical Engineering Series, Boston: Springer, 2007, pp.
101-114.</li>
<li>Cândida M. Pereira, Amílcar L. Ramalho, Jorge A. Ambrósio. A
critical overview of internal and external cylinder contact force
models. Nonlinear Dynamics, 2010, 63 (4), pp.681-697.</li>
<li>Some slids in web:
https://my.mech.utah.edu/~me7960/lectures/Topic2-FundamentalsOfErrors.pdf</li>
</ol>
]]></content>
      <tags>
        <tag>mehcanics</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数型与指数型傅里叶变换的联系</title>
    <url>/2023/07/03/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%9E%8B%E4%B8%8E%E6%8C%87%E6%95%B0%E5%9E%8B%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="三角函数型">三角函数型</h2>
<p>对于一个周期为 <span class="math inline">\(T\)</span> 的信号 <span
class="math inline">\(x(t)\)</span>，其基频为 <span
class="math inline">\(f_1=1/T\)</span>。对 <span
class="math inline">\(x(t)\)</span> 进行傅里叶展开：</p>
<p><span class="math display">\[
x(t) = \frac{a_0}{2} +\sum^{\infty}_ {n=1} \left[ a_n \cos\left(2\pi n
f_1 t \right) + b_n \sin\left(2\pi n f_1 t \right) \right]
\]</span></p>
<p>上式中的 <span class="math inline">\(a_n\)</span> 和 <span
class="math inline">\(b_n\)</span> 是傅里叶系数：</p>
<p><span class="math display">\[
a_n = \frac{2}{T} \int^T_ 0 x(t) \cos \left( 2\pi n f_1 t \right) dt
\]</span></p>
<p><span class="math display">\[
b_n = \frac{2}{T} \int^T_ 0 x(t) \sin \left( 2\pi n f_1 t \right) dt
\]</span></p>
<p>三角函数型的傅里叶变换也可以写成余弦函数形式（三参数）：</p>
<p><span class="math display">\[
x(t) = \frac{c_0}{2} + \sum^{\infty}_ {n=1} \left[ c_n \cos\left(2\pi n
f_1 t + \varphi_n\right)  \right]
\]</span></p>
<p>其中：</p>
<p><span class="math display">\[
c_n = \sqrt{a_n^2 + b_n^2}
\]</span></p>
<p><span class="math display">\[
\varphi_n = \mathrm{arctan}(-\frac{b_n}{a_n})
\]</span></p>
<h2 id="指数型">指数型</h2>
<p>欧拉公式建立了三角函数与指数之间的桥梁。</p>
<p><span class="math display">\[
\cos \left( 2\pi n f_1 t \right) = \frac{1}{2} \left[ e^{j2\pi n f_1 t}
+  e^{-j2\pi n f_1 t} \right]
\]</span></p>
<p><span class="math display">\[
\sin \left( 2\pi n f_1 t \right) = \frac{1}{2j} \left[ e^{j2\pi n f_1 t}
-  e^{-j2\pi n f_1 t} \right]
\]</span></p>
<p>将欧拉公式带入三角函数型的傅里叶变换后，令：</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{a_n - j b_n}{2}
\]</span></p>
<p>设<span
class="math inline">\(f_1\)</span>代表傅里叶变换后的基频，<span
class="math inline">\(j\)</span>表示虚数单位，则傅里叶变换可以写为：
<span class="math display">\[
x(t) = \sum^{\infty}_ {n=-\infty}  X(2\pi n f_1)   e^{ j 2\pi n f_1 t
}   
\]</span></p>
<p>式中的 $X(2n f_1) $ 展开后为：</p>
<p><span class="math display">\[
\begin{gathered}
X(2\pi n f_1) =\frac{1}{2} \left[ \frac{2}{T} \int^T_ 0 x(t) \cos \left(
2\pi n f_1 t \right) dt - \frac{2j}{T} \int^T_ 0 x(t) \sin \left( 2\pi n
f_1 t \right) dt \right] \\\\
= \frac{1}{T} \int^T_ 0 x(t) \left[ \cos \left( 2\pi n f_1 t \right) - j
\sin \left( 2\pi n f_1 t \right) \right] dt
\end{gathered}
\]</span></p>
<p>再利用欧拉公式，可得：</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{1}{T} \int^T_ 0 x(t)   e^{ -j 2\pi n f_1 t} dt
\]</span></p>
<h2 id="两者的联系">两者的联系</h2>
<p>已知：</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{a_n - j b_n}{2}
\]</span></p>
<p>上式为复数，在复平面内可以被表示为：</p>
<p><span class="math display">\[
X(2\pi n f_1) = \frac{1}{2} \sqrt{a_n^2 + b_n^2}
e^{j\mathrm{arctan}(-\frac{b_n}{a_n})}
\]</span></p>
<p>其中<span class="math inline">\(\frac{1}{2} \sqrt{a_n^2 +
b_n^2}\)</span>为复数的模，<span
class="math inline">\(\mathrm{arctan}(-\frac{b_n}{a_n})\)</span>为复数的幅角。</p>
<p>观察此复数的模、幅角与三角函数型傅里叶变化间的异同可知，复数的模等于余弦信号$c_n
(2n f_1 t + _n) $幅值的一半。</p>
<p><span class="math display">\[
|X(2\pi n f_1)| = \frac{1}{2} \sqrt{a_n^2 + b_n^2} = \frac{1}{2} c_n
\]</span></p>
<p>复数的幅角等于余弦信号$c_n (2n f_1 t + _n) $初相位。</p>
<p><span class="math display">\[
\varphi_n = \mathrm{arctan}(-\frac{b_n}{a_n})
\]</span></p>
]]></content>
      <tags>
        <tag>振动测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 标记语言常用命令</title>
    <url>/2021/06/12/Markdown%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="markdown基本语法">Markdown基本语法</h1>
<h2 id="标题">标题</h2>
<p>添加标题：在文本前加<code>#</code>，<code>#</code>的数目代表标题的级别，最高支持六级标题
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure> ## 字体 斜体：<code>*被添加斜体的文本*</code>
加粗：<code>**被加粗文本**</code>
倾斜加粗：<code>***被倾斜加粗的文本***</code>
加删除线：<code>~~被加删除线的文本~~</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*被添加斜体的文本*  </span><br><span class="line">**被加粗文本**</span><br><span class="line">***被倾斜加粗的文本***</span><br><span class="line">~~被加删除线的文本~~</span><br></pre></td></tr></table></figure> 效果演示：
<em>被添加斜体的文本</em> <strong>被加粗文本</strong>
<strong><em>被倾斜加粗的文本</em></strong>
<del>被加删除线的文本</del></p>
<h2 id="分割线">分割线</h2>
<p>在空行内输入<code>---</code>或<code>___</code>或<code>***</code>即可，符号中间也可插入空格。效果如下：</p>
<hr />
<h2 id="引用">引用</h2>
<p>在被引用的文字前加<code>&gt;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;这是一段引用内容，它很长很长很长很长很长很长很长------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">&gt;</span><br><span class="line">&gt;这是第二段引用内容，它很短</span><br></pre></td></tr></table></figure> 效果如下：
&gt;这是一段引用内容，它很长很长很长很长很长很长很长------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
&gt; &gt;这是第二段引用内容，它很短</p>
<p>也可以控制引用的级别，<code>&gt;</code>的个数代表级别 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;一级文本：对于命途多舛的人生，以及渺茫的时间，阻挡在我们之间这一事实，我们无可奈何。</span><br><span class="line">&gt;&gt;二级文本：彼方为谁，无我有问。九月露湿，待君之前。</span><br><span class="line">&gt;&gt;&gt;三级文本：但盼风雨来、能留你在此;即使天无雨、我亦留此地。</span><br></pre></td></tr></table></figure>
效果如下：
&gt;一级文本：对于命途多舛的人生，以及渺茫的时间，阻挡在我们之间这一事实，我们无可奈何。
&gt;&gt;二级文本：彼方为谁，无我有问。九月露湿，待君之前。
&gt;&gt;&gt;三级文本：但盼风雨来、能留你在此;即使天无雨、我亦留此地。 ##
列表 <strong>列表分为无序列表和有序列表。</strong>
无序列表使用<code>-</code>或<code>*</code>或<code>+</code>进行标记，标记和文本之间要有空格，不同标记可以混用，效果相同。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Harry James Potter</span><br><span class="line">* Hermione Jean Granger</span><br><span class="line">+ Ronald Bilius &quot;Ron&quot; Weasley</span><br></pre></td></tr></table></figure> 效果演示： - Harry James Potter * Hermione Jean Granger +
Ronald Bilius "Ron" Weasley</p>
<p>有序列表使用<code>1.</code>，即任意数字加英文句号进行标记，并且数字不影响最终编译效果。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Albus Percival Wulfric Brian Dumbledore</span><br><span class="line">8. Severus Snape</span><br><span class="line">10. Minerva McGonagall</span><br></pre></td></tr></table></figure> 1. Albus Percival Wulfric Brian Dumbledore 8. Severus
Snape 10. Minerva McGonagall</p>
<p><strong>列表可以嵌套</strong>
在上一级与下一级列表之间敲三个空格即可。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Lord Voldemort</span><br><span class="line">    * Lupin</span><br><span class="line">    * Dobby</span><br><span class="line">        * Winky</span><br><span class="line">        * Tom Riddle </span><br></pre></td></tr></table></figure> 效果演示： * Lord
Voldemort * Lupin * Dobby * Winky * Tom Riddle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Lord Voldemort</span><br><span class="line">    1. Lupin</span><br><span class="line">    1. Dobby</span><br><span class="line">        1. Winky</span><br><span class="line">        1. Tom Riddle </span><br></pre></td></tr></table></figure>
<p>效果演示： 1. Lord Voldemort 1. Lupin 1. Dobby 1. Winky 1. Tom
Riddle</p>
<p><strong>列表包含多个段落</strong>
列表包含多个段落，每个项目下的段落都缩进4个空格或一个制表符。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   Harry Potter, Protagonist, is a thin, black-haired youth wearing glasses on his forehead with a lightning-shaped scar, just as suddenly a short time overstating the children who, like flavor is not good. </span><br><span class="line">    He is a Magic School fifth-grade students, but also a man of Hogwarts. Since Voldemort after the resurrection, the scar on his forehead to his burning often endless.</span><br></pre></td></tr></table></figure> 效果演示： * Harry Potter, Protagonist, is a thin,
black-haired youth wearing glasses on his forehead with a
lightning-shaped scar, just as suddenly a short time overstating the
children who, like flavor is not good. He is a Magic School fifth-grade
students, but also a man of Hogwarts. Since Voldemort after the
resurrection, the scar on his forehead to his burning often endless.</p>
<h2 id="代码">代码</h2>
<p><strong>在行内插入简短的代码</strong>
把代码插入<code>``</code>之间即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看起来`codes and codes`是这样的</span><br></pre></td></tr></table></figure> 效果演示：
看起来<code>codes and codes</code>是这样的</p>
<p><strong>在行间插入代码块</strong>
把代码块放入两行<code>```</code>之间(<code>\</code>是为了防止转义，实际写作中是没有的)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\```</span><br><span class="line">start</span><br><span class="line">codes and codes</span><br><span class="line">end</span><br><span class="line">\```</span><br></pre></td></tr></table></figure> 效果演示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">codes and codes</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h2 id="强制空行">强制空行</h2>
<p>在空行内使用<code>\</code>即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一段</span><br><span class="line">\</span><br><span class="line">\</span><br><span class="line">第二段</span><br></pre></td></tr></table></figure> 效果演示： 第一段<br />
<br />
第二段</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
